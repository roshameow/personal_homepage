---
layout: post
title: hash映射
categories:
  - algorithm
tags:
  - content
last_modified_at: 2025-10-05T19:42
created: 2025-09-25T18:19
---
估算alpha id 和什么有关

有些hash会非常相似. 目的, 得到alpha id的全部编码信息: 秒级的timestamp+machine id

44/s. 2640/min. 1w consultant. 每人回测100/ 5min. 

44x3600x24/10000 = 380 次/天. 这和实际结果很不符合.

1天5w. 
### 假设1: 


| 可能的方案                                    | 做法                                                                                                                 | 特点                                                                                                   | 输入        | 输出                                   |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------- | --------- | ------------------------------------ |
| **密码**学hash函数<br>(SHA-256 / SHA-1 / MD5) | **碎纸机**:<br>→ 生成和输出相同的初始值<br>加入输入的内容进行各种非线性混合<br>重复多次                                                              | 1. 相近的输入会输出完全不同的结果<br>2. 可以人为制造hash冲突                                                                | 任意长度二进制文本 | md5: 128bit/32hex<br>SHA-256: 256bit |
| 多项式除法的**校验**码<br>(CRC32)                 | 把输入的任意长度看成(mod2)多项式$M(x)$<br>→ 指定生成多项式$G(x)$ <br>得到输出为 residue $R(x)$<br><br>实际中通过移位+XOR实现                         | 1. 常见的变化, 输出可预测<br>(单比特错、双比特错、突发错)                                                                   | 任意长度二进制文本 | CRC32: 32bit/8hex<br>                |
| 文本**去重**, 片段**匹配**<br>Rolling Hash       | 把字符串看成B进制整数, 对M取residue                                                                                            | 1. 计算方便<br>2. 根据hash能快速找到相同字串<br>3. 不是强校验, 冲突常见<br>4. 相似字串hash差别大                                    | 任意长度字符串   | 整数                                   |
| 相似度**聚类**(LSH)<br>(MinHash, SimHash)     | MinHash:<br>提取文本特征, 映射成整数集合<br>→ 用n组随机hash函数<br>$h(x)=ax+b(\mod P)$ 对集合每个元素hash<br>每个hash值取hash最小值<br><br><br><br> | 1. 比较hash值有多少位重复, <br>就能知道文本中有多少重复特征<br>2. 可以把整数分成band, <br>用于LSH bucketing                          | 任意大小整数集合  | 取决于算法的超参数<br>n 位 int vector<br>      |
|                                          | SimHash(PCAHash, Spectral Hash):<br>输入向量<br>→用n个投影向量<br>计算投影, 二进制化                                                 | 1. 相似的向量会使hash值相同位数多,<br>从而可以被LSH bucketing召回<br>2. 过程和逻辑回归一样都是线性+激活. <br>用逻辑回归训练+预测, <br>准确率应该高于0.5 | 固定长度向量    | n bit                                |
|                                          |                                                                                                                    |                                                                                                      |           |                                      |


- 假设1: 由pnl(长2496位的float vector)编码
	- pnl 是

相同pnl不同user -> hash不同
排除这个假设的原因: 生成一系列pnl完全相同的alpha, hash有些是相似但不同, 但有些完全不同. 

### 假设2

user id和hash同为7位. 是否用xor加密. 验证. 

`hash_a ^ id_a == hash_b ^ id_b` 也 **不成立**
### 假设2

expression
- ast clean


排除这个假设的原因: 两个表达式完全不相关的alpha, hash相似
- 猜测是不是settings, 表达式, user id的联合编码. 


统计重复的hash前缀个数
### 假设3

时间

统计「前缀 → 时间」的关系
把 dateCreated 转成秒或分钟级的 时间戳。
按 hash 前缀分组，算时间戳的 均值 / 分布范围。
如果「相同前缀的时间非常接近」，说明前缀和时间相关

前缀与创建时间的相关性
出现次数多的前缀通常集中在较短时间区间内（span_sec 不大），说明相同前缀的 ID 可能是同时生成的。
反过来, 固定时间段, 前缀也固定同样的44种. 跨相邻时间段, 就变成88种.

这验证了你之前的猜测：hash 前缀和 dateCreated 时间有关，ID 的前缀不是完全随机，生成算法可能会受时间影响或按批次生成

可视化验证
可以画出 时间 vs hash 前缀 的散点图


这样你就能看到：
前缀长度为 1 → 有多少种不同前缀
前缀长度为 2 → 有多少种不同前缀
…
直到 max_len。
📈 如果前缀确实和时间强相关，你会看到 前缀长度增加时，唯一前缀数量接近样本数（说明前缀逐渐唯一化）。


时间主导，但横向有并发带 这就是我现在看到的情况

同样时间平行带大概有44个左右

歪路:
猜测prefix之间的关系. 👍 从你的结果可以看出明显的规律：
mod 16
大部分前缀落在 [0,5,10,15,6,9,...]，集中在少数几个余数上。
说明前缀低位每 16 有一个间隔的规律，但还有一些偏移（可能是并发带/随机部分）。
mod 32
余数集中在 16,0,10 等位置，说明低位有更大的分段，仍然有少量分散。
mod 64
集中在 16 和几个其他余数上，每个余数对应大概一组“平行带”。
这非常吻合你观察到的 “同一时间平行带大概 44 个左右” 的现象。
低位取模 64 时，可以把并发带分离出来。
mod 128
更大模数开始显得稀疏，主要几个值有重复。
说明前缀的低位并没有均匀分布，而是有特定分片/并发槽的规律。

**按 count 或 span_sec 排序**，那就用 `sort_values`

只用到44个字符

为什么选择44字符? 可能是URL-safe / visually unambiguous alphabet 防止混淆 -> I/L, O/0 没有这种规律

有 **纯数字 + 大写**：`0G, 1G, … 9G`. 猜测不同平行带可能等距 -> 图上就能看出是个错误猜测

猜测同一种混淆方式? 没法验证 

猜测通过出现频率计算混淆顺序 -> 这种想法没有道理

把平行带分开计算

- 发现hash变化有明显的周期, 
- 画图

- 推测BASE44的顺序
	- 是统一的?
		- 如果是统一的, 应该是真正的进位. 但是同时出现了 0N-> 0x, PY -> Px, pM->px 所以我的猜测应该不对
	- 还是不同bucket 不同

- 指数假设: `log(decoded-intercept) = log(A) + B * timestamp`
	- 固定intercept的情况
	- exp优化的自由度太高了. 数值算法无法收敛