<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://roshameow.github.io//personal_homepage/atom.xml" rel="self" type="application/atom+xml" /><link href="https://roshameow.github.io//personal_homepage/" rel="alternate" type="text/html" /><updated>2025-02-21T06:08:29+00:00</updated><id>https://roshameow.github.io//personal_homepage/atom.xml</id><title type="html">Liu, Wen’s Home Page</title><subtitle>Work, Experiments and Ideas.</subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><entry><title type="html">blender学习: 制作随音乐律动的视频</title><link href="https://roshameow.github.io//personal_homepage/blender/blender-learning20/" rel="alternate" type="text/html" title="blender学习: 制作随音乐律动的视频" /><published>2025-02-20T00:00:00+00:00</published><updated>2025-02-21T13:43:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/blender/blender-learning20</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/blender/blender-learning20/"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1CPNpeTE5E/">参考教学</a></p>

<ul>
  <li>设置物体随1d强度变化:
    <ul>
      <li>在plane mesh上添加Cloud Texture, 把strength打上关键帧</li>
      <li>用geometry node在变形的mesh上添加instance
        <ul>
          <li>把material的link从Data改为Object才能给instance添加材质</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>添加音乐:
    <ul>
      <li>设置物体随音乐(1d)运动: 用Graph Editor的<a href="https://docs.blender.org/manual/en/latest/editors/graph_editor/channels/editing.html">Channel</a> -&gt; Sound to Samples 功能, 让strength随音乐变化</li>
      <li>设置播放音乐: 在Video Sequencer里添加音乐</li>
    </ul>
  </li>
</ul>

<iframe src="//player.bilibili.com/player.html?isOutside=true&amp;aid=114040038755496&amp;bvid=BV1pTAZeNEhW&amp;cid=28499775428&amp;p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="blender" /><category term="content" /><category term="music" /><category term="geometry_node" /><category term="video_editor" /><summary type="html"><![CDATA[参考教学]]></summary></entry><entry><title type="html">传感器颜色调制 (四) – 多光谱颜色校准</title><link href="https://roshameow.github.io//personal_homepage/algorithm/color-moderate3/" rel="alternate" type="text/html" title="传感器颜色调制 (四) – 多光谱颜色校准" /><published>2025-02-12T00:00:00+00:00</published><updated>2025-02-21T09:56:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/algorithm/color-moderate3</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/algorithm/color-moderate3/"><![CDATA[<h2 id="用rgb校准多光谱数据">用RGB校准多光谱数据</h2>

<p>把<code class="language-plaintext highlighter-rouge">(H,W,N)</code> 的多光谱数据 <code class="language-plaintext highlighter-rouge">Y</code> , 由<code class="language-plaintext highlighter-rouge">N x 3</code> 的CCM(Color Correction Matrix) 线性映射为 <code class="language-plaintext highlighter-rouge">(H,W,3)</code> 的rgb数据 <code class="language-plaintext highlighter-rouge">X</code> . 即 $Y\cdot CCM = X$ .</p>

<ul>
  <li>虽然是线性映射, 可以在步骤前给Y 加一个 feature extraction模块, 实现非线性. 达到更低的loss.</li>
  <li>即使只是线性映射, 多光谱数据也比3通道的数据能达到更低的loss.
    <h3 id="求解系数">求解系数</h3>
  </li>
</ul>

<table>
  <thead>
    <tr>
      <th>Loss &amp; 约束</th>
      <th>公式</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>普通L2 norm</td>
      <td>$\min \vert\vert Y\cdot CCM - X\vert\vert_2$</td>
      <td> </td>
    </tr>
    <tr>
      <td>restrict awb</td>
      <td>$\min \vert\vert Y\cdot CCM - X\vert\vert_2$ ,  $\sum_{col}(CCM)=1$</td>
      <td>让中性灰映射不变, 即让 (1,1,…,1)映射到(1,1,1)<br />一般是把wb(white balance)步骤放在color correction之前会这样做<br />因为wb在不同机器上表现差别更大, <br />所以给这两步设置不同的校准频率吗?</td>
    </tr>
    <tr>
      <td>L2 Regularization<br />🌟</td>
      <td>$\min \vert\vert Y\cdot CCM - X\vert\vert_2 + \lambda\cdot\vert\vert CCM \vert\vert_2$</td>
      <td>防止CCM因为数据点比较少而过拟合<br />如果用24色卡, 考虑多光谱数据有 3n 个未知数, <br />加入约束是十分必要的, 这个也是计算最简单的约束条件</td>
    </tr>
    <tr>
      <td>Lasso</td>
      <td>$\min \vert\vert Y\cdot CCM - X\vert\vert_2 + \lambda\cdot\vert\vert CCM \vert\vert_1$</td>
      <td>防止CCM某个数据过大外, 还能增强稀疏性<br />在color-correction里没必要</td>
    </tr>
    <tr>
      <td>CIELab<br />🌟</td>
      <td>把 X 变换到Lab空间. <br />计算 $Y\cdot CCM$ 和 X的delta E loss</td>
      <td>Lab 是评判RGB数据是否相近的最终标准. 这一步也是必要的.<br />Lab 变换是非线性的, 这一步优化时间更长.<br />需要在线性优化得到初值之后, 第二步再做delta E 的优化.</td>
    </tr>
  </tbody>
</table>

<ol>
  <li><strong>原始L2 norm</strong>:  用<strong>最小二乘法</strong></li>
  <li><strong>restrict awb条件</strong> : 因为是线性条件, 可以直接求解.
    <ul>
      <li>把awb条件写成: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250220192803.png" alt="Pasted image 20250220192803.png" width="300" /> 的形式</li>
      <li>直接代入原方程: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250220192840.png" alt="Pasted image 20250220192840.png" width="1000" />
        <ul>
          <li>把 Y 和 CCM 分块展开并化简. 用<strong>最小二乘法</strong>求解化简后的方程即可.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>L2 Regularization</strong> : 因为正则项也是L2的, 可以直接计算.
    <ul>
      <li>在求导时, CCM的系数由 $2Y^T Y$ 变为 $2Y^TY+2\begin{bmatrix}\lambda&amp;&amp; \\ &amp;\lambda&amp; \\ &amp;&amp;\lambda\end{bmatrix}$ 即可</li>
    </ul>
  </li>
  <li><strong>Lasso问题</strong>: 可以用近端算子轮流迭代的方法优化.</li>
  <li><strong>Delta E</strong> : 用BFGS 的方法优化.</li>
</ol>

<h3 id="测量标准">测量标准</h3>

<ul>
  <li>数据来源:
    <ul>
      <li>标准色卡</li>
      <li>色差仪测量: 理论上能组成很大的数据集, 但是很多材料没有好的反射性能</li>
    </ul>
  </li>
  <li>测量环境
    <ul>
      <li>保证测量到的都是反射光</li>
      <li>控制光源, 如果用色差仪和色差仪的光源保持一致</li>
    </ul>
  </li>
</ul>

<h3 id="结果可视化">结果可视化</h3>

<ul>
  <li>色卡: <img src="/personal_homepage/docs/attachment/color_check_result.png" alt="color_check_result.png" width="300" /> 显示校准后和标准色的直观差距</li>
  <li>Lab色彩: <img src="/personal_homepage/docs/attachment/lab_chromaticities.png" alt="lab_chromaticities.png" width="200" /> 显示数据集在ab空间的分布, 以及校准后的lab色差</li>
  <li>在给出多光谱sensor每个通道的光谱(<code class="language-plaintext highlighter-rouge">cmf = n x 28</code> )的情况下, 可以出示下面两图: 由<code class="language-plaintext highlighter-rouge">(cmf_T * cmf)^{-1} * cmf</code> 做为系数, 还可以加入一些Regularization
    <ul class="task-list">
      <li>校准数据光谱: <img src="/personal_homepage/docs/attachment/color_spectrum.png" alt="color_spectrum.png" width="300" />  显示数据集的光谱分布.</li>
      <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />多光谱映射的RGB和真实RGB的光谱差距. 即色卡上的红, 蓝, 绿三色.</li>
    </ul>
  </li>
</ul>

<h3 id="代码">代码</h3>

<ul>
  <li><a href="https://gist.github.com/roshameow/8855383a21cab1b36bba130a6cee70a5#file-color_plot-py"><strong>color_plot.py</strong></a></li>
</ul>

<h2 id="用多光谱合成高光谱数据">用多光谱合成高光谱数据</h2>

<p>多光谱 + 高光谱分布 -&gt; 高光谱</p>

<ul>
  <li>数据采集: (多光谱,高光谱) 数据对
    <ul>
      <li>自然状态下采集的高光谱数据集(反射光+光源)</li>
      <li>多光谱数据每个通道光谱 -&gt; 由高光谱数据合成的多光谱数据</li>
    </ul>
  </li>
  <li>模型
    <ul>
      <li>考虑现实世界情况, 带kernel的模型(<a href="https://en.wikipedia.org/wiki/Radial_basis_function_network">rbf</a> )比较合适?</li>
    </ul>
  </li>
</ul>

<h2 id="用多光谱做awb">用多光谱做awb</h2>

<p>即在多光谱数据中去掉光源的影响. 多光谱 + 光源分布 -&gt; 光源的 rgb illuminant vector.</p>

<ul>
  <li>数据采集: (多光谱, rgb illuminant vector) 数据对
    <ul>
      <li>自然状态下采集的光源的高光谱数据集 -&gt; 转换成多光谱数据集和rgb illuminant vector数据集</li>
      <li>仿真: 从已知 (相机拍摄的rgb图片,rgb illuminant vector)  + 相机的response曲线 + 光源的光谱数据集 + 反射谱数据集 -&gt; 推测出图片每个像素的光谱
        <ul>
          <li><code class="language-plaintext highlighter-rouge">相机的response曲线 * 光源的光谱 = rgb illuminant vector</code></li>
          <li><code class="language-plaintext highlighter-rouge">相机的response曲线 *  光源的光谱 * 反射谱 = rgb像素</code></li>
          <li>用<a href="https://en.wikipedia.org/wiki/Maximum_likelihood_estimation">最大似然估计</a> 的想法, 先估计出图片光源光谱, 再估计出每个像素的反射光谱</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="reference">reference</h2>

<p>[1]  Koskinen, Samu, Erman Acar, and Joni-Kristian Kämäräinen. “Single Pixel Spectral Color Constancy.” <em>International Journal of Computer Vision</em>, September 1, 2023. <a href="https://doi.org/10.1007/s11263-023-01867-x">https://doi.org/10.1007/s11263-023-01867-x</a>.</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="algorithm" /><category term="content" /><category term="sensor" /><category term="multi-spectrum" /><category term="isp" /><category term="proximal_operator" /><summary type="html"><![CDATA[用RGB校准多光谱数据]]></summary></entry><entry><title type="html">blender学习: 制作水体</title><link href="https://roshameow.github.io//personal_homepage/blender/blender-learning19/" rel="alternate" type="text/html" title="blender学习: 制作水体" /><published>2025-02-10T00:00:00+00:00</published><updated>2025-02-10T12:29:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/blender/blender-learning19</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/blender/blender-learning19/"><![CDATA[<h2 id="用displacementnoise-texture制作">用displacement+noise texture制作</h2>

<p><a href="https://www.youtube.com/watch?v=ke-MgwUxLjI">参考教学</a></p>

<ol>
  <li>用一个plain mesh代表水体</li>
  <li>制作水体颜色: Glossy + <a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/refraction.html">Refraction(折射)</a>  + <a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/transparent.html">Transparent</a>
    <ul>
      <li>Glossy + <a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/refraction.html">Refraction(折射)</a> 设置一个透明效果(参考玻璃的做法)
        <ul>
          <li>Refraction的Roughness通过波动调节(增强动态效果)</li>
        </ul>
      </li>
      <li><a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/shader/transparent.html">Transparent</a>  设置成蓝色, 相当于一个蓝色滤光片. 加在最后. 只有Cycles 渲染有用.</li>
    </ul>
  </li>
  <li>制作波动: 用<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/texture/noise.html">noise texture node</a> 输入displacement制作
    <ol>
      <li>我们的输出的是2d的plain. 用3d noise和4d noise的区别是?</li>
    </ol>
  </li>
</ol>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="blender" /><category term="content" /><category term="shader" /><summary type="html"><![CDATA[用displacement+noise texture制作]]></summary></entry><entry><title type="html">切菜板成分</title><link href="https://roshameow.github.io//personal_homepage/daily/cutting-board/" rel="alternate" type="text/html" title="切菜板成分" /><published>2025-02-09T00:00:00+00:00</published><updated>2025-02-10T10:18:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/daily/cutting-board</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/daily/cutting-board/"><![CDATA[<h2 id="材质">材质</h2>

<p>自身硬度和使用的适用性矛盾.</p>

<table>
  <thead>
    <tr>
      <th>材质</th>
      <th>耐高温</th>
      <th>洗碗机</th>
      <th>开裂发霉</th>
      <th>碎屑</th>
      <th>适用性</th>
      <th>建议</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>不锈钢/陶瓷/石材</td>
      <td>✔️</td>
      <td>✔️</td>
      <td>x</td>
      <td>x</td>
      <td>打滑, 伤刀</td>
      <td> </td>
    </tr>
    <tr>
      <td>塑料<br />麦秸秆(内含塑料)</td>
      <td>✔️</td>
      <td>✔️<br /></td>
      <td>不容易<br /></td>
      <td>PE材质<br />高温下对人体有害</td>
      <td> </td>
      <td>不切需要烹饪的生食</td>
    </tr>
    <tr>
      <td>木质</td>
      <td> </td>
      <td> </td>
      <td>✔️<br /></td>
      <td>不会产生有害物质</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>楠竹</td>
      <td> </td>
      <td> </td>
      <td>✔️</td>
      <td>不容易</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="daily" /><category term="content" /><summary type="html"><![CDATA[材质]]></summary></entry><entry><title type="html">worldquant BRAIN 股票因子 (四) – 因子思路</title><link href="https://roshameow.github.io//personal_homepage/finance/alphas4/" rel="alternate" type="text/html" title="worldquant BRAIN 股票因子 (四) – 因子思路" /><published>2025-01-22T00:00:00+00:00</published><updated>2025-02-18T08:36:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/finance/alphas4</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/finance/alphas4/"><![CDATA[<h2 id="事件">事件</h2>

<ul>
  <li>并购(M&amp;A)</li>
</ul>

<h2 id="分析师数据">分析师数据</h2>

<ul>
  <li>employee</li>
  <li><code class="language-plaintext highlighter-rouge">anl4_adjusted_netincome_ft</code>  本身就是个很好的指标
    <ul>
      <li>各种变形<code class="language-plaintext highlighter-rouge">group_netralize, ts_mean, winsorize , +其他alpha</code> 也都可以</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">anl4_flag_erbfintax</code></li>
  <li><code class="language-plaintext highlighter-rouge">anl4_totassets_number</code></li>
</ul>

<h2 id="一些优化alpha的通用技巧">一些优化alpha的通用技巧</h2>

<ul>
  <li><strong>双重中性化</strong>: 让alpha对两个group都做中性化, 即在group (A x B) 上中性化.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">group=densify((group_B + 1)*1000 + group_A)</code>  把两个group编码到一个group里.</li>
      <li>没想到两个group可以相加.</li>
      <li>类似于transformer中常用的, 把position embedding和text embedding用sum编码到一起.</li>
    </ul>
  </li>
  <li><strong>双重排序</strong>: 和双重中性化类似. 给主要datafield A 一个很大的权重. 得到字典排序的效果.</li>
  <li><strong>设置“止盈止损”</strong>: 原来的写法好像有问题.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">close_at_event = trade_when(event1, close, -1);  alpha = trade_when(event2, signal, abs(close - close_at_event) / close &gt; .1);</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">close_at_event</code>是<code class="language-plaintext highlighter-rouge">event1</code> 上次发生时的<code class="language-plaintext highlighter-rouge">close</code>. 如果上次<code class="language-plaintext highlighter-rouge">event1</code> 的影响超过10%, 对股票强制平仓.
            <ul>
              <li>比如<code class="language-plaintext highlighter-rouge">event1</code> 是上涨. 连续n天下跌导致影响超过10% 时, 强制平仓.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">close_at_event = trade_when(not(event), close, -1);alpha=(abs(close - close_at_event) / close &gt; .1)? nan : signal</code> 好像更符合逻辑
        <ul>
          <li>event 连续发生导致影响超过 10% 则强制平仓</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>月度调仓</strong>:</li>
</ul>

<h3 id="交易条件">交易条件</h3>

<ul>
  <li><strong>判断市场的波动性</strong>:
    <ul>
      <li>用<code class="language-plaintext highlighter-rouge">trade_when(市场波动性,alpha, -1)</code>控制alpha的适用范围.</li>
      <li>“系统风险度量”数据集, 新闻数据集, 情绪数据集</li>
    </ul>
  </li>
  <li><strong>识别市场特殊时期</strong>: 比如在回报特别差的时期关闭交易
      <code class="language-plaintext highlighter-rouge">count_of_each_group = group_count(1,subindustry); #计算每个组别的股票数量  
      drawdown_num = if_else(returns&lt;-0.09,1,0); #如果大幅下跌则计数1，否则为0  
      sum_of_drawdown = group_sum(drawdown_num,subindustry); #计算每天各组内大幅下跌股票的总数  
      ratio = sum_of_drawdown/count_of_each_group; #计算出各组的大幅下跌股票数量占比  
      alpha = if_else(ratio&gt;0.6,nan,signal) #如果本组超过60%的股票都在大幅下跌，则赋值nan.</code></li>
  <li><strong>只取特殊股票交易</strong>:
    <ul>
      <li>比如市值靠前的股票: <code class="language-plaintext highlighter-rouge">filter = if_else(rank(cap)&gt;0.9,1,nan)</code></li>
    </ul>
  </li>
</ul>

<h2 id="参考资料">参考资料</h2>

<p>[1]   <a href="https://support.worldquantbrain.com/hc/en-us/community/posts/15152019662487--%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99-BRAIN%E5%B0%8F%E8%B4%B4%E5%A3%AB-%E8%BF%99%E9%87%8C%E6%9C%89%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E7%A1%AC%E6%A0%B8%E5%86%85%E5%AE%B9-%E6%8C%81%E7%BB%AD%E5%91%A8%E6%9B%B4%E4%B8%AD">【学习资料】BRAIN小贴士(这里有你想要的硬核内容！持续周更中）</a></p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="finance" /><category term="content" /><summary type="html"><![CDATA[事件]]></summary></entry><entry><title type="html">worldquant BRAIN 股票因子 (三) – API使用和代码</title><link href="https://roshameow.github.io//personal_homepage/code/alphas3/" rel="alternate" type="text/html" title="worldquant BRAIN 股票因子 (三) – API使用和代码" /><published>2025-01-18T00:00:00+00:00</published><updated>2025-02-10T20:57:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/code/alphas3</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/code/alphas3/"><![CDATA[<h2 id="仿真流程">仿真流程</h2>

<h3 id="api功能">API功能</h3>

<ul>
  <li>登陆: <code class="language-plaintext highlighter-rouge">https://api.worldquantbrain.com/authentication</code></li>
  <li>获得数据字段: <code class="language-plaintext highlighter-rouge">https://api.worldquantbrain.com/data-fields?</code></li>
  <li>发起仿真测试: <code class="language-plaintext highlighter-rouge">https://api.worldquantbrain.com/simulations</code></li>
  <li>查询结果, 打标签: <code class="language-plaintext highlighter-rouge">https://api.worldquantbrain.com/alphas/{alpha_id}</code></li>
</ul>

<h3 id="批量仿真流程">批量仿真流程</h3>

<ol>
  <li>开启异步session</li>
  <li>尝试登陆</li>
  <li>生成仿真数据, 把仿真数据存入csv文件, 计算任务数量</li>
  <li>批量开启仿真回测, 处理可能出现的任何异常(登陆超时,发送过快,回测被拒绝)
    <ol>
      <li>发起请求</li>
      <li>发起回测成功(response中包含<code class="language-plaintext highlighter-rouge">Location</code>) -&gt; 获得回测状态(得到simulation id)</li>
      <li>🔄 不断请求回测状态</li>
      <li>回测状态变为结束(response中<code class="language-plaintext highlighter-rouge">Retry-After=0, status=[COMPLETE,WARNING]</code>) -&gt; 获得结果(得到alpha id)</li>
    </ol>
  </li>
</ol>

<h3 id="问题">问题</h3>

<ul>
  <li>理论上可以不去监测每个请求的发送情况. <strong>simulation id在回测结束后不会改变不会销毁</strong>. 所以, 批量发送请求拿到simulation id后, 可以后续再查看simulation的运行结果.</li>
  <li>本身<code class="language-plaintext highlighter-rouge">sess.get</code> 请求的过程等待只能由异步解决, 但是在这个项目里, 好像也没必要?</li>
  <li>平台限制了回测请求的并发数, 但是获取数据好像并没有限制.</li>
  <li>我经常对<code class="language-plaintext highlighter-rouge">template.py</code>元编程, python在用<code class="language-plaintext highlighter-rouge">importlib</code> 加载模块时, 会自动加载同名的缓存. 所以要记得手动reload. 否则会发现修改无效 😮‍💨</li>
</ul>

<h2 id="数据测试">数据测试</h2>

<p>利用平台的统计平均正结果(longCount) 和平均负结果(shortCount) 的功能</p>

<h3 id="测试数据分布">测试数据分布</h3>

<ul>
  <li>平台支持统计 <code class="language-plaintext highlighter-rouge">{datafield} &lt; {a}</code> 的平均股票数(longCount)</li>
  <li>用<a href="https://en.wikipedia.org/wiki/Minifloat">Minifloat</a> 的想法, 先选择 <strong>指数</strong> 的切分点, 然后把中间部分用 <strong>有效数</strong> 等分</li>
</ul>

<p><img src="/personal_homepage/docs/attachment/Pasted%20image%2020250210190821.png" alt="Pasted image 20250210190821.png" width="400" /></p>

<table class="wikitable" style="text-align: center; width: 50px">
<tbody><tr>
<th width="12.5%">sign(符号位)
</th>
<th width="50%" colspan="4">exponent(指数)
</th>
<th width="37.5%" colspan="3">significand(有效数)
</th></tr>
<tr>
<td style="background: #d5ffff">0
</td>
<td style="background: #a4ffb4">0
</td>
<td style="background: #a4ffb4">1
</td>
<td style="background: #a4ffb4">1
</td>
<td style="background: #a4ffb4">0
</td>
<td style="background: #ffb2b4">1
</td>
<td style="background: #ffb2b4">1
</td>
<td style="background: #ffb2b4">0
</td></tr></tbody></table>

<ul>
  <li>拿BF8举例,   先选择 指数 的切分点, 然后把中间部分用 有效数 等分
    <ul>
      <li>exponent部分(4位, 2^{-6}-2^7)为, $0110b=6$  -&gt; $2^{6-7}=\frac{1}{2}$</li>
      <li>significand部分(3位, 0/8-7/8 )为, $110b=6$ -&gt; $1+\frac{6}{8}$</li>
      <li>最后事例的数字为 $(1+\frac{6}{8})*\frac{1}{2}$</li>
    </ul>
  </li>
  <li>第一轮选用base10的指数点做切分, 统计每个区间内的股票数</li>
  <li>第二轮选 5%-95% 的分位点区间, 再进行等分.</li>
</ul>

<h3 id="测试数据覆盖率">测试数据覆盖率</h3>

<ul>
  <li>用 <code class="language-plaintext highlighter-rouge">({datafield} != {a})? 1: -1</code> 的正负统计平均 zeros(shortCount), non-zeros(longCount), nan(剩下的) 值</li>
</ul>

<h3 id="测试数据更新频率">测试数据更新频率</h3>

<ul>
  <li>用 <code class="language-plaintext highlighter-rouge">ts_std_dev({data_fields},{d}) != 0 ? 1 : 0</code> 统计数据在周期d天内是否更新.</li>
  <li>d 选择一些常用的更新频率: 天, 星期, 月, 季度, 年等</li>
</ul>

<h2 id="代码">代码</h2>

<ul>
  <li><a href="https://github.com/roshameow/quantnight">https://github.com/roshameow/quantnight</a></li>
</ul>

<h2 id="参考资料">参考资料</h2>

<p>[1]  https://support.worldquantbrain.com/hc/en-us/community/posts/11807866133911–BRAIN-TIPS-6-ways-to-quickly-evaluate-a-new-dataset</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="code" /><category term="content" /><category term="python" /><category term="async" /><category term="worldquant" /><summary type="html"><![CDATA[仿真流程]]></summary></entry><entry><title type="html">协程的用法</title><link href="https://roshameow.github.io//personal_homepage/tool/asyncio/" rel="alternate" type="text/html" title="协程的用法" /><published>2025-01-16T00:00:00+00:00</published><updated>2025-02-10T20:16:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/tool/asyncio</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/tool/asyncio/"><![CDATA[<p>协程就是单线程多任务, 在一个任务等待的时候干点别的其他的任务. 所以包含等待的函数都要用协程的版本: 在需要时交出event loop的控制权.</p>
<h2 id="python-协程的用法">python 协程的用法</h2>

<p>在python里把一个协程函数也叫coroutine</p>

<ul>
  <li>yield(生成器): 会把当前函数挂起, 交出event loop的控制权给调用方, 再次调用函数时从暂停处继续.
    <ul>
      <li>包含yield的函数会变成一个coroutine</li>
      <li><code class="language-plaintext highlighter-rouge">next()</code>会激活coroutine</li>
      <li>一个主要用法是用于创建超大的list, 不会直接创建好占用内存.</li>
      <li>缺点是无法直接得到list的size</li>
    </ul>
  </li>
  <li>yield from
    <ul>
      <li>可以自动循环可迭代对象</li>
    </ul>
  </li>
  <li>future</li>
  <li>asyncio
    <ul>
      <li>async 函数不会马上执行其中代码, 而是返回coroutine</li>
      <li>await 相当于yield from: 捕获StopIteration异常, 把StopIteration的value属性的值变为yield from表达式的值
        <ul>
          <li>后面可以是task/coroutine/future</li>
        </ul>
      </li>
      <li>task: 可以被执行的函数
        <ul>
          <li>create_task 可以生成task</li>
          <li>await 也会</li>
          <li>asyncio.run() 的时候会执行task</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>aiohttp</li>
  <li>特点:
    <ul>
      <li>需要每个子任务结束主动告知(运行结束, return)</li>
    </ul>
  </li>
  <li>可以用<code class="language-plaintext highlighter-rouge">inspect</code> 的<code class="language-plaintext highlighter-rouge">getgeneratorstate</code> 查看协程(coroutine)的状态</li>
</ul>

<h2 id="javascript的用法">javascript的用法</h2>

<ul>
  <li>callback</li>
  <li>promise</li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="tool" /><category term="content" /><category term="python" /><category term="async" /><category term="异步" /><summary type="html"><![CDATA[协程就是单线程多任务, 在一个任务等待的时候干点别的其他的任务. 所以包含等待的函数都要用协程的版本: 在需要时交出event loop的控制权. python 协程的用法]]></summary></entry><entry><title type="html">worldquant BRAIN 股票因子 (二) – 因子思路</title><link href="https://roshameow.github.io//personal_homepage/finance/alphas2/" rel="alternate" type="text/html" title="worldquant BRAIN 股票因子 (二) – 因子思路" /><published>2025-01-15T00:00:00+00:00</published><updated>2025-02-18T08:47:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/finance/alphas2</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/finance/alphas2/"><![CDATA[<p>一些因子的来源和原理</p>

<h2 id="对公司经营状况的预估基本数据">对公司经营状况的预估(基本数据)</h2>

<p>fundamental datasets</p>

<ul>
  <li>运营盈利: 只对大型公司有效
    <ul>
      <li>盈利/支出
        <ul>
          <li><code class="language-plaintext highlighter-rouge">-rank(ebit/capex)</code>
            <ul>
              <li>投入更多到运营盈利上的公司不怎么样</li>
              <li><code class="language-plaintext highlighter-rouge">0.3*group_rank(ebit/assets,subindustry)- 0.7*group_neutralize(ts_mean(ebit,210)/ts_mean(capex,210),subindustry)</code></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>资产估值/盈利
        <ul>
          <li><code class="language-plaintext highlighter-rouge">alpha = -group_rank(fnd2_ebitdm, industry)-group_rank(fnd2_ebitfr, industry); group_rank(fn_assets_fair_val_a,industry)&gt;0.5?alpha*2 : alpha</code>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">fnd2_ebitdm</code> domestic ebit, <code class="language-plaintext highlighter-rouge">fnd2_ebitfr</code> foreign ebit</li>
              <li><code class="language-plaintext highlighter-rouge">fn_assets_fair_val_a</code> 资产估值</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>留存收益: 未分配给股东的利润
    <ul>
      <li><code class="language-plaintext highlighter-rouge">rank(ts_delta(retained_earnings / sharesout, 90))</code>
        <ul>
          <li>留存收益/股本=每股留存收益: 不受公司规模影响</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">-ts_rank(retained_earnings,250)</code>
        <ul>
          <li>留存收益比历史减少, 可能是分红给股东了</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>营业收入:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ts_rank(operating_income,252)</code>
        <ul>
          <li>营业收入越高越好,</li>
          <li>结合相对股价看(operating_income/close), 如果营业收入增长而股价未能跟上，可能意味着市场尚未充分定价公司改善的前景</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>负债
    <ul>
      <li>短期债务: 限制同行业比较
        <ul>
          <li><code class="language-plaintext highlighter-rouge">zscore(cash_st/debt_st)</code>
            <ul>
              <li>现金流越高, 还债能力越强</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>负债公允价值（Fair Value of Liabilities）,公司负债在市场上的当前价值
        <ul>
          <li><code class="language-plaintext highlighter-rouge">-ts_rank(fn_liab_fair_val_l1_a,252)</code></li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">liabilities/assets</code>, <code class="language-plaintext highlighter-rouge">debt/assets</code>
        <ul>
          <li>高杠杆可能带来高回报</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>收入
    <ul>
      <li>税前收入, 销售数量(sales)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">quantile(ts_rank(pretax_income,250))</code>
            <ul>
              <li>税前收入越靠前的公司越好</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>递延收入: 订阅型业务, 长期合约, 预付款业务
        <ul>
          <li><code class="language-plaintext highlighter-rouge">slope = ts_regression(fnd6_newqv1300_drcq,step(1),252,rettype=2); rank(slope)</code></li>
          <li>计算<code class="language-plaintext highlighter-rouge">dr</code>(deferred revenue)的斜率, 增长说明需求增加, 可能股票会涨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="对外部事件的响应">对外部事件的响应</h2>

<ul>
  <li>新闻影响
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ts_backfill(vec_avg(nws12_prez_4l),504)</code>
        <ul>
          <li>新闻发布后股价提升4%的时间</li>
          <li><code class="language-plaintext highlighter-rouge">ts_backfill(vec_sum(nws12_prez_57p),600)</code></li>
          <li><code class="language-plaintext highlighter-rouge">alpha=ts_backfill(vec_avg(nws12_prez_4l),504); trade_when(volume&gt;adv20,alpha,-1)</code></li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">(ts_arg_max(ts_backfill(news_session_range, 20), 60))</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">signed_power(ts_backfill(vec_avg(nws12_prez_4l),504)*(1+rank(volume)),2)</code></li>
          <li>新闻后的波动范围(high-low)越大, 应该做多?? 一个季度内, 到达最大波动范围的最近时间. 越长说明波动衰减的正常. 不会极端的受到</li>
          <li>需要用随时间变化快的decay, 和trade_when控制换手率</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">news_tot_ticks</code> 市场上所有交易品种一天内变价次数之和</li>
    </ul>
  </li>
  <li>新闻情绪</li>
  <li>社媒:  对volume做neuntralize
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-scl12_buzz</code>
        <ul>
          <li>讨论多的认为是负面情绪</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">ts_std_dev(ts_backfill(snt_social_value,60),60)</code>
        <ul>
          <li>在一段时间内有关注是好事, 注意区分不同类型的股票</li>
          <li>优化: <code class="language-plaintext highlighter-rouge">C60=correlation_last_60_days_spy;Alpha=zscore(ts_std_dev(ts_backfill(snt_social_value, 60),60));trade_when (C60&lt;0.4,Alpha, C60&gt;0.6)</code>
            <ul>
              <li>做zscore 变换</li>
              <li>和标普指数(SPY) 相关性不能太高(关键)</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">-ts_mean(pv13_ustomergraphrank_hub_rank,504)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">hub</code> 公司在网络中的中心度, 越低说明对其他合作伙伴依赖越少, 更稳定, 注意区分不同类型的股票</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>volatility(波动率)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(implied_volatility_call_120/parkinson_volatility_120)^0.1</code>
        <ul>
          <li>历史波动率: daily return的标准差</li>
          <li>Implied Volatility(隐含波动率): 通过期权定价模型计算</li>
          <li>Parkinson波动率: 通过价格区间(high-low/close)计算</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">trade_when(pcr_oi_270 &lt; 1, (implied_volatility_call_270-implied_volatility_put_270), -1)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">pcr_oi_270</code> (put-call-ratio)未平仓合约数, 小于1 的话(call&gt;put)说明市场看涨</li>
          <li>可以根据历史波动率分组, 提升subuniverse-test, 很有效</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="对市场表现的预估量价数据">对市场表现的预估(量价数据)</h2>

<p>Price-volume datasets</p>

<h3 id="常用数据">常用数据</h3>

<ul>
  <li>开盘价, 收盘价,</li>
  <li>vwap(volume weighted avg price) 当天的平均</li>
  <li>adv20(avg days volume 20, 过去20天的平均volume)
    <ul>
      <li>一个常用的条件是<code class="language-plaintext highlighter-rouge">trade_when(volume &gt; adv20, alpha, -1)</code> 表示流动性突然变高</li>
    </ul>
  </li>
  <li>成交量: 根据市值(cap)分组, 不同波动时期区别对待
    <ul>
      <li><code class="language-plaintext highlighter-rouge">alpha = (1/volume);group = bucket(rank(cap),range ='0.25,1,0.25');group_rank(alpha,group);</code>
        <ul>
          <li>成交量太活跃不是好事</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>5日回归: <code class="language-plaintext highlighter-rouge">-rank(close-ts_mean(close,5))</code></li>
  <li>
    <p>turnover</p>
  </li>
  <li>相关性
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-ts_corr(ts_backfill(fscore_momentum,66),ts_backfill(fscore_value,66),756)</code>
        <ul>
          <li>估值(市盈率（P/E）、市净率（P/B）等财务指标来估算)和动量(股票价格变化率计算)的相关性高, 说明股票价格和价值分离?</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>风险
    <ul>
      <li><code class="language-plaintext highlighter-rouge">SR = systematic_risk_last_60_days;USR = unsystematic_risk_last_60_days;zscore(USR + SR)</code>
        <ul>
          <li>总风险, 高风险是好的?</li>
          <li>去掉和指数相关性高的股票? <code class="language-plaintext highlighter-rouge">trade_when(correlation_last_60_days_spy &gt; 0.6, zscore(systematic_risk_last_60_days + unsystematic_risk_last_60_days),-1)</code></li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">market_ret = ts_product(1+group_mean(returns,1,market),250)-1;rfr = vec_avg(fnd6_newqeventv110_optrfrq);expected_return = rfr+beta_last_360_days_spy*(market_ret-rfr);actual_return = ts_product(returns+1,250)-1;actual_return-expected_return</code>
        <ul>
          <li>CAPM(Capital Asset Pricing Model): <code class="language-plaintext highlighter-rouge">rfr</code> 是risk free rate + beta * (return - rfr)</li>
          <li>如果股票的CAMP-adjusted return是正数, 说明是好事</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="参考资料">参考资料</h2>

<p>[1]  https://platform.worldquantbrain.com/learn/documentation</p>

<p>[2]  Kakushadze, Zura. “101 Formulaic Alphas.” SSRN Scholarly Paper. Rochester, NY: Social Science Research Network, December 9, 2015. <a href="https://doi.org/10.2139/ssrn.2701346">https://doi.org/10.2139/ssrn.2701346</a>.    <strong>Alpha101</strong> 主要用到量价数据</p>

<p>[3] Wang, Ying, Bohui Zhang, and Xiaoneng Zhu. “<strong>The Momentum of News.</strong>” SSRN Scholarly Paper. Rochester, NY: Social Science Research Network, October 16, 2018. <a href="https://doi.org/10.2139/ssrn.3267337">https://doi.org/10.2139/ssrn.3267337</a>.   新闻动量和基本面相关</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="finance" /><category term="content" /><category term="stock" /><category term="alpha" /><summary type="html"><![CDATA[一些因子的来源和原理]]></summary></entry><entry><title type="html">worldquant BRAIN 股票因子 (一) – 仿真测试</title><link href="https://roshameow.github.io//personal_homepage/finance/alphas/" rel="alternate" type="text/html" title="worldquant BRAIN 股票因子 (一) – 仿真测试" /><published>2025-01-07T00:00:00+00:00</published><updated>2025-02-19T11:28:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/finance/alphas</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/finance/alphas/"><![CDATA[<p>选择在模拟盘中表现好的因子投资</p>

<h2 id="仿真">仿真</h2>

<h3 id="仿真参数">仿真参数</h3>

<p>分为数据库选择, 和后处理两部分</p>

<ul>
  <li>Delay: 当天(在当天closed前根据当天数据交易), 或+1天(早上交易, 根据昨天的数据)</li>
  <li>Test Period: 把仿真的5年时间分出一部分作为test, PnL图上orange的部分</li>
  <li>
    <p>Universe(股票范围): Top3000指日平均 <code class="language-plaintext highlighter-rouge">volume</code> 最大的3000支</p>
  </li>
  <li>Decay: 自带的一个linear decay(前n天), 是在最后的normalized weight上进行decay</li>
  <li>pasteurized: ? 只考虑universe以内的alpha?</li>
  <li>Nan Handling: 操作不可控? OFF的话, 有Nan的值会被平仓(全部卖出)</li>
  <li>Unit Handling: 单位不匹配时报warning</li>
  <li>truncation: 设置maximum weight上限: 建议设置0.05~0.1 (entailing 5-10%)之间</li>
  <li>neutralize(标准化): 让mean(alpha)=0,
    <ul>
      <li>时间(<code class="language-plaintext highlighter-rouge">ts_neutralize</code>)上做neutralize避免长期趋势. (多空中性化).</li>
      <li>同期(<code class="language-plaintext highlighter-rouge">group_neutralize</code>)的做避免不同类型股票的不公平比较.</li>
    </ul>
  </li>
</ul>

<h2 id="仿真交易流程">仿真交易流程</h2>

<ul>
  <li>输入为  <code class="language-plaintext highlighter-rouge">Matrix</code>, 按照时间顺序交易</li>
  <li><a href="https://platform.worldquantbrain.com/learn/documentation/create-alphas/how-brain-platform-works">仿真交易规则</a>:
    <ul>
      <li>每天用恒定的账面规模(<code class="language-plaintext highlighter-rouge">book size</code>)交易,
        <ul>
          <li>book size 为$20 million. 有$10 million现金, 投资上限为$20million.</li>
        </ul>
      </li>
      <li>alpha apply到每只股票上得到alpha value</li>
      <li>L1 归一化,  得到每只股票的<code class="language-plaintext highlighter-rouge">weight</code>
        <ul>
          <li>不同neutralize组的booksize是分别计算的? 比如有两个sector, 每个sector scale到 0.5/abs(sector_sum)?</li>
        </ul>
      </li>
      <li>每天在每只股票上投资 <code class="language-plaintext highlighter-rouge">weight*booksize</code></li>
      <li>计算<code class="language-plaintext highlighter-rouge">PnL</code></li>
    </ul>
  </li>
</ul>

<h2 id="数据">数据</h2>

<p>有<code class="language-plaintext highlighter-rouge">Matrix</code>, <code class="language-plaintext highlighter-rouge">Vector</code>, <code class="language-plaintext highlighter-rouge">Group</code> 三种</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Matrix</code> : 天数 x 股票的2d array. 普通的alpha可以用</li>
  <li><code class="language-plaintext highlighter-rouge">Vector</code>: 每天每只股票可能有0-n个数值, 比如新闻. 需要用vector_operator处理</li>
  <li><code class="language-plaintext highlighter-rouge">Group</code>: 每只股票一个group_id. 用于group_operator的group参数</li>
</ul>

<h2 id="测试结果">测试结果</h2>

<h3 id="术语">术语</h3>

<ul>
  <li>PnL(profit and loss): <code class="language-plaintext highlighter-rouge">daily_PnL = sum(size of position * daily_return)</code>
    <ul>
      <li>每个股票的 <code class="language-plaintext highlighter-rouge">daily_return= (today’s close / yesterday’s close) – 1.0 </code></li>
    </ul>
  </li>
  <li>Returns: <code class="language-plaintext highlighter-rouge">Return = annualized PnL / Half of Book Size</code></li>
  <li>Drowndown: PnL最大的一次下降, 用half of booksize归一化为百分比</li>
  <li>Long/Short(做多, 做空): 在这里就指买入/卖出
    <ul>
      <li>Long/short Count: 做多/做空 股票的数量</li>
    </ul>
  </li>
  <li><a href="https://www.investopedia.com/terms/v/volume.asp#:~:text=Volume%20is%20the%20amount%20of,its%20daily%20open%20and%20close">Volume(成交量)</a> : 一段时间的交易数量</li>
  <li>Margin(边缘收益): <code class="language-plaintext highlighter-rouge">Margin=PnL/TotalDollarsTraded</code>
    <ul>
      <li>一段时间内每个dollor的收益, 和可能会用到的手续费有关.</li>
    </ul>
  </li>
  <li>cap(市值)</li>
  <li>Call/Put(看涨/看跌)</li>
</ul>

<h3 id="通过指标">通过指标</h3>

<table>
  <thead>
    <tr>
      <th><a href="https://platform.worldquantbrain.com/learn/documentation/interpret-results/alpha-submission">指标</a></th>
      <th>要求</th>
      <th>公式</th>
      <th>优化方向</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Sharpe_ratio">Sharpe(夏普率, related metric, information ratio, IR)</a></td>
      <td>Delay-0: <code class="language-plaintext highlighter-rouge">Sharpe &gt; 2</code><br />Delay-1: <code class="language-plaintext highlighter-rouge">Sharpe &gt; 1.25</code></td>
      <td><code class="language-plaintext highlighter-rouge">Sharpe=mean(PnL)/stdev(PnL)*sqrt(252)</code><br /><br /><code class="language-plaintext highlighter-rouge">*sqrt(252)</code> 年化</td>
      <td> </td>
    </tr>
    <tr>
      <td>Sub-universe Sharpe</td>
      <td>建议 <code class="language-plaintext highlighter-rouge">subuniverse_sharpe &gt; 0.7*sharpe</code></td>
      <td><code class="language-plaintext highlighter-rouge">subuniverse_sharpe &gt;= 0.75 * sqrt(subuniverse_size / alpha_universe_size) * alpha_sharpe</code><br /><br />不在sub-universe 的股票赋NaN, 自动加上market neutralization, 并乘上scale?<br /><br /></td>
      <td>让alpha少受公司规模, 流动性的影响<br />避免使用<code class="language-plaintext highlighter-rouge">1-rank(cap), rank(-assets)</code><br />对<code class="language-plaintext highlighter-rouge">volume*close</code> 不在一个水平的stock,</td>
    </tr>
    <tr>
      <td><a href="https://support.worldquantbrain.com/hc/en-us/articles/20251419309719-How-to-improve-Turnover">Turnover(换手率)</a></td>
      <td><code class="language-plaintext highlighter-rouge">1% &lt; Turnover &lt; 70%</code><br />建议 <code class="language-plaintext highlighter-rouge">Turnover &lt; 25%</code></td>
      <td><code class="language-plaintext highlighter-rouge">avg(daily trading volume/Booksize)</code></td>
      <td>减少turnover: <br />1. 增加滤波(decay, ts_mean)<br />2. 用trade_when设置交易条件<br />3. 用<code class="language-plaintext highlighter-rouge">hump</code> operator</td>
    </tr>
    <tr>
      <td><strong><a href="https://support.worldquantbrain.com/hc/en-us/articles/20251386376471-How-to-increase-fitness-of-alphas?">Fitness(健康度)</a></strong><br />评价alpha优劣的指标</td>
      <td>Delay-0: <code class="language-plaintext highlighter-rouge">fitness &gt; 1.3</code><br />Delay-1: <code class="language-plaintext highlighter-rouge">fitness &gt; 1</code></td>
      <td><code class="language-plaintext highlighter-rouge">Fitness = Sharpe*sqrt(abs(Returns)/Max(Turnover,0.125))</code></td>
      <td>降低turnover</td>
    </tr>
    <tr>
      <td>Margin</td>
      <td>建议 <code class="language-plaintext highlighter-rouge">margin &gt; 4bps</code></td>
      <td><code class="language-plaintext highlighter-rouge">avg(PnL/total traded dollars)</code></td>
      <td>降低turnover</td>
    </tr>
    <tr>
      <td>Weight test</td>
      <td>1. 在长时间内, non-zero weight的股票数不能太少<br />2. 某一个股票的weight不能占比太大<br /><code class="language-plaintext highlighter-rouge">max(weight) &lt; 10%</code> <br />随股票范围变动</td>
      <td> </td>
      <td>- truncation: 设置maximum weight上限: 建议设置0.05~0.1 (entailing 5-10%)之间<br />- 调整weight 分布: rank<br />- <a href="https://support.worldquantbrain.com/hc/en-us/articles/19248385997719-Weight-Coverage-common-issues-and-advice?">解决coverage不够的问题</a>:1. 用<code class="language-plaintext highlighter-rouge">ts_backfill</code>填补一些更新频率不够的 2. 用<code class="language-plaintext highlighter-rouge">group_count</code>检测当天的覆盖率</td>
    </tr>
    <tr>
      <td>Self Correlation</td>
      <td>和现有alpha不相关:<br /><code class="language-plaintext highlighter-rouge">&lt; 0.7 PnL correlation</code><br />, 或优化现有alpha:<br /><code class="language-plaintext highlighter-rouge">Sharpe &gt; 110% * correlated Sharpe</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><a href="https://platform.worldquantbrain.com/learn/documentation/interpret-results/parameters-simulation-results#is-semi-os-os">Out-of-sample(OS)</a></td>
      <td>提交后在真实市场测试</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>IS Ladder Sharpe(阶梯测试)</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="操作">操作</h2>

<ul>
  <li>数据接口: https://platform.worldquantbrain.com/data
    <ul>
      <li>datafield是变量名</li>
      <li>dataset是数据集</li>
    </ul>
  </li>
  <li>支持运算: https://platform.worldquantbrain.com/learn/operators</li>
  <li><a href="https://platform.worldquantbrain.com/learn/documentation/discover-brain/introduction-brain-expression-language">代码语法</a>:
    <ul>
      <li>只用给出的运算符</li>
      <li>每行用 <code class="language-plaintext highlighter-rouge">;</code> 结尾
常用的operator</li>
    </ul>
  </li>
  <li>填空(<code class="language-plaintext highlighter-rouge">ts_backfill</code>,  <code class="language-plaintext highlighter-rouge">group_backfill</code>): 把数据里的nan用有效值补上
    <ul>
      <li><code class="language-plaintext highlighter-rouge">group_backfill</code> 是在d天, group里取所有的有效值, 做winsorized mean</li>
    </ul>
  </li>
  <li>统计
    <ul>
      <li>mean(<code class="language-plaintext highlighter-rouge">group_mean,</code>)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">group_sum</code></li>
          <li><code class="language-plaintext highlighter-rouge">group_count</code> : 统计valid value. 和 group_sum(is_nan ) 一样吗?</li>
        </ul>
      </li>
      <li>std_dev(<code class="language-plaintext highlighter-rouge">group_std_dev</code>)</li>
      <li>ir(<code class="language-plaintext highlighter-rouge">ts_ir</code>): 信噪比, mean/std</li>
      <li>kurt(<code class="language-plaintext highlighter-rouge">ts_kurtosis</code>):</li>
      <li>max (<code class="language-plaintext highlighter-rouge">ts_max_diff</code>)</li>
    </ul>
  </li>
  <li>调整分布
    <ul>
      <li>neutralize(<code class="language-plaintext highlighter-rouge">group_neutralize,ts_av_diff</code>): 让数据 mean=0</li>
      <li>zscore(<code class="language-plaintext highlighter-rouge">zscore, group_zscore, ts_zsore</code>): 让数据 mean=0, var=1. 假设数据是高斯分布的情况下标准化.</li>
      <li>rank(<code class="language-plaintext highlighter-rouge">rank, group_rank, ts_rank</code>): 不改变单调性, 把数据调整成0-1之间的均匀分布</li>
      <li>quantile(<code class="language-plaintext highlighter-rouge">quantile, ts_quantile</code>) 把数据调整成某个分布
        <ul>
          <li>会先做一个rank把数据调整到0-1, 再做线性变换到 (1/n)-(1-1/n), 然后再用三种分布调整</li>
          <li>支持均匀分布, gaussian分布和<a href="https://en.wikipedia.org/wiki/Cauchy_distribution">Cauchy分布</a>
            <ul>
              <li><strong>把输入调整成return, 可以用来做随机采样?</strong></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>缩尾: 中间部分数据不变, 用来处理长尾分布.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">tail</code> : 手动设置lower, upper bound</li>
          <li><code class="language-plaintext highlighter-rouge">winsorize</code>:  离群数据的截断的范围由std确定</li>
        </ul>
      </li>
      <li>scale(<code class="language-plaintext highlighter-rouge">scale, group_scale, ts_scale</code>): 让数据在0-1之间. 线性scale</li>
      <li>线性分段函数改变数据分布: 比如<code class="language-plaintext highlighter-rouge">a&lt;0.1? (1.1-a):(a&gt;0.8? 1.8-a:1)</code> , 可以构造任何分布.</li>
      <li>非线性的改变数据分布(<code class="language-plaintext highlighter-rouge">power, -inverse, log(x+1),arctan</code>)</li>
    </ul>
  </li>
  <li>计算相关关系
    <ul>
      <li>ts_regression(y,x): 用一个数据线性拟合另一个数据. 调节rettype 获得对应参数
        <ul>
          <li>error_term(rettype=0): 相当于用x数据做y的baseline_wander (y信号是主信号)</li>
          <li>slope($\beta$ , rettype=2): 得到数据x关于数据y的系数,
            <ul>
              <li>可以用这个信号作为一个阈值</li>
              <li>得到的 <code class="language-plaintext highlighter-rouge">slope * x</code> 可以用做把y对多个x做分解, 得到的分解量. 和rettype=3 类似.</li>
            </ul>
          </li>
          <li>y-estimate(rettype=3): 相当于用x数据线性构建信号, 调节出一个和y 距离最近的参数. (x信号是主信号)</li>
          <li>$R^2=1-\frac{SSE}{SST}$ (决定系数, rettype=6): 表示线性模型的有用程度.(比直接取均值好的程度.). (反应了x对y的预测能力.)
            <ul>
              <li>SSE是模型预测值与实际值 $y_i$ 的平方和. SST是均值与实际值 $y_i$ 的平方和. 这两个越接近, 即$R^2$ 越小, 说明模型和直接取均值效果差不多.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>分组
    <ul>
      <li>floor: 用整数量化成n个区间.</li>
      <li>bucket: 把0-1的值平均分为n个区间.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">floor(rank(cap)*4.99)</code> 和<code class="language-plaintext highlighter-rouge">bucket(rank(cap),range="0.1,1,0.2")</code> 是差不多的效果.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>控制
    <ul>
      <li>hump: 根据数据变动, 只有两种action(不动, 移动hump threshold)
        <ul>
          <li>对周期比较长的数据(比如基本面数据)可以这样做</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="参考资料">参考资料</h2>

<p>[1]   https://support.worldquantbrain.com/hc/en-us/community/posts/28643095649943–新人科普-一文助你成为BRAIN兼职研究顾问</p>

<p>[2]  https://support.worldquantbrain.com/hc/en-us/community/posts/19273239621399–Alpha灵感启示录-合集-持续更新收录中</p>

<p>[3]  https://support.worldquantbrain.com/hc/en-us/community/posts/22863075241623–学习资料-BRAIN平台自学路径图推荐</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="finance" /><category term="content" /><category term="stock" /><category term="alpha" /><category term="simulation" /><summary type="html"><![CDATA[选择在模拟盘中表现好的因子投资]]></summary></entry><entry><title type="html">blender学习: 用几何节点做程序化城市</title><link href="https://roshameow.github.io//personal_homepage/blender/blender-learning18/" rel="alternate" type="text/html" title="blender学习: 用几何节点做程序化城市" /><published>2025-01-04T00:00:00+00:00</published><updated>2025-01-07T17:14:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/blender/blender-learning18</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/blender/blender-learning18/"><![CDATA[<p>参考<a href="https://www.youtube.com/watch?v=LheRoTgym8g">这个教学</a></p>

<p>1:  <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250105115526.png" alt="Pasted image 20250105115526.png" width="150" />  -&gt; 2:  <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250105121905.png" alt="Pasted image 20250105121905.png" width="150" />  -&gt; 3: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106164220.png" alt="Pasted image 20250106164220.png" width="150" /> -&gt; 4: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106164521.png" alt="Pasted image 20250106164521.png" width="150" /> -&gt; 5: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106164825.png" alt="Pasted image 20250106164825.png" width="150" /></p>

<ul>
  <li>制作道路:
    <ol>
      <li>制作随机网格: 随机2, 3层细分
        <ul>
          <li>用二层 <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/subdivide_mesh.html">subdivide Mesh</a></li>
          <li>随机选一些内部网格 (<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/geometry/operations/separate_geometry.html">Separate Geometry Node -&gt; Face</a> ) 再进行一层subdivide
            <ul>
              <li>输入Boolean的随机值</li>
              <li>输出选中的和未选中的不同处理</li>
              <li>用<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/geometry/join_geometry.html">Join Gemetry Node</a>  融合在一起</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>制作随机扭曲: 把随机的mesh merge在一起
        <ul>
          <li>用<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/geometry/operations/merge_by_distance.html">Merge by Distance Node</a> 融合: 输入Boolean的随机值, distance选择0.26( 稍 &gt; 2级细分, 即1/4)</li>
          <li>再次用0.01的distance 融合: 去除重复的边</li>
        </ul>
      </li>
      <li>把网格转成道路
        <ul>
          <li>mesh转成折线curve: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/mesh_to_curve.html">Mesh to Curve</a></li>
          <li>折线curve转成圆角曲线: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/mesh_to_curve.html">Fillet Curve</a> (类似Bevel倒角的效果)
            <ul>
              <li>Count 控制中间点的个数, Radius控制圆角弧度大小, 选择Limit Radius 保证圆角起终点不会超出范围(什么情况是需要超出范围的吗? 这个选项总是要选)</li>
            </ul>
          </li>
          <li><strong>转成道路: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/curve/operations/curve_to_mesh.html">Curve to Mesh</a> (效果为Curve沿Profile Curve 挤出)</strong>
            <ul>
              <li>Curve 处输入我们的道路curve</li>
              <li>Profile Curve 处用<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/curve/primitives/curve_line.html">Curve Line</a> 输入一个固定长度线段Curve</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>增加厚度: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/extrude_mesh.html">Extrude Mesh Node</a> 沿面的法相挤出</li>
      <li>关闭自动的Smooth Shading: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/write/set_shade_smooth.html">Set Shade Smooth Node</a></li>
    </ol>
  </li>
</ul>

<p>1: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106204640.png" alt="Pasted image 20250106204640.png" width="150" />  -&gt; 2: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106205132.png" alt="Pasted image 20250106205132.png" width="150" />  -&gt; 3: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106214511.png" alt="Pasted image 20250106214511.png" width="150" /> -&gt; 4: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106214738.png" alt="Pasted image 20250106214738.png" width="150" /></p>

<ul>
  <li>制作建筑物: 安插在道路网格的间隙
    <ol>
      <li>制作底座: 把折线道路(道路步骤2的结果)向内挤出
        <ul>
          <li><a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/extrude_mesh.html">Extrude Mesh Node</a> 沿面的法相挤出, 但是厚度为0</li>
          <li>选中输出<code class="language-plaintext highlighter-rouge">Top</code>(新生成的面)向内scale</li>
        </ul>
      </li>
      <li>制作楼体:
        <ul>
          <li>把底座内部向上拉伸</li>
          <li>去掉第一步制作底座时没用的mesh, 只保留底座拉伸部分</li>
        </ul>
      </li>
      <li>制作屋顶:
        <ul>
          <li>选中楼体顶部:
            <ul>
              <li><a href="https://docs.blender.org/manual/en/3.1/modeling/geometry_nodes/input/normal.html">Normal Node</a> + <a href="https://docs.blender.org/manual/en/latest/compositing/types/vector/separate_xyz.html">Spearate XYZ Node</a> 的<code class="language-plaintext highlighter-rouge">Z</code>输出, 连接到 <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/extrude_mesh.html">Extrude Mesh Node</a> 的<code class="language-plaintext highlighter-rouge">Selection</code> 上</li>
              <li>另一种方法是直接选中楼体时的<code class="language-plaintext highlighter-rouge">Top</code> 输出, 连接到 <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/extrude_mesh.html">Extrude Mesh Node</a> 的<code class="language-plaintext highlighter-rouge">Selection</code> 上</li>
            </ul>
          </li>
          <li>把楼体顶部向下向内挤出(和上一步制作楼体的方法一样)</li>
        </ul>
      </li>
      <li>把街区内部进一步切分, 和道路放在一起</li>
    </ol>
  </li>
</ul>

<p><img src="/personal_homepage/docs/attachment/Pasted%20image%2020250107055846.png" alt="Pasted image 20250107055846.png" width="150" /></p>

<ul>
  <li>shading: 在cycles渲染模式下
    <ul>
      <li>world: 添加一个Sky Texture, 适当调整参数</li>
      <li>object:
        <ul>
          <li>楼体: 每幢楼随机两个贴图
            <ul>
              <li>用<a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/input/geometry.html">Geometry Node</a> 的random per Island(每个connected component随机) 的功能 + constant Color Ramp(把数值映射成 0 或 1 )</li>
              <li>mix shader混合</li>
            </ul>
          </li>
          <li>楼顶: 用<a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/input/geometry.html">Geometry Node</a> 的normal +  <a href="https://docs.blender.org/manual/en/latest/compositing/types/vector/separate_xyz.html">Spearate XYZ Node</a> 的<code class="language-plaintext highlighter-rouge">Z</code>输出, 选中楼顶</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="texture-coordinate-的设置"><a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/input/texture_coordinate.html">texture Coordinate</a> 的设置</h2>

<ul>
  <li>我们用<a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/textures/image.html">Image Texture</a> 设置颜色的映射时, 把默认的 flat 改为 box
    <ul>
      <li>flat的映射: <img src="https://docs.blender.org/manual/en/latest/_images/render_shader-nodes_textures_image_projection-flat.png" alt="flat" />Sphere的映射方法: <img src="https://docs.blender.org/manual/en/latest/_images/render_shader-nodes_textures_image_projection-box.png" alt="box" /></li>
    </ul>
  </li>
</ul>

<h2 id="用到的blender的一些快捷键功能">用到的blender的一些快捷键功能</h2>

<ul>
  <li>打开关闭侧边 Transform栏: N</li>
  <li>Object Mode:
    <ul>
      <li><a href="https://docs.blender.org/manual/en/latest/scene_layout/object/editing/apply.html">Apply(应用变形)</a>: Command + A
        <ul>
          <li>比例尺(Apply Scale): 应用后, 物体上的变换, 由比例变成实际距离?
            <ul>
              <li>比如400scale的物体, 应用前 0.1 的变换, 和应用后40m的变换等价</li>
              <li>blender的滑块单位是0.1, 可能是有时候物体太大, 按比例调整不方便?</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Geometry Nodes合并成group
    <ul>
      <li>在原有Node输入的地方可以加input Node
        <ul>
          <li>input Node的参数不能改名字</li>
          <li>Node内部的参数不能改成输入😮‍💨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="blender" /><category term="content" /><category term="geometry_node" /><summary type="html"><![CDATA[参考这个教学]]></summary></entry></feed>