<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://roshameow.github.io//personal_homepage/atom.xml" rel="self" type="application/atom+xml" /><link href="https://roshameow.github.io//personal_homepage/" rel="alternate" type="text/html" /><updated>2025-01-18T13:12:16+00:00</updated><id>https://roshameow.github.io//personal_homepage/atom.xml</id><title type="html">Liu, Wen’s Home Page</title><subtitle>Work, Experiments and Ideas.</subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><entry><title type="html">worldquant BRAIN 股票因子 (三) – API使用</title><link href="https://roshameow.github.io//personal_homepage/code/alphas3/" rel="alternate" type="text/html" title="worldquant BRAIN 股票因子 (三) – API使用" /><published>2025-01-18T00:00:00+00:00</published><updated>2025-01-18T21:08:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/code/alphas3</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/code/alphas3/"><![CDATA[<ul>
  <li>测试dataset的方法: https://platform.worldquantbrain.com/learn/documentation/understanding-data/data 主要是通过coverage,</li>
</ul>

<p>[1]  https://support.worldquantbrain.com/hc/en-us/community/posts/11807866133911–BRAIN-TIPS-6-ways-to-quickly-evaluate-a-new-dataset</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="code" /><category term="content" /><category term="python" /><summary type="html"><![CDATA[测试dataset的方法: https://platform.worldquantbrain.com/learn/documentation/understanding-data/data 主要是通过coverage,]]></summary></entry><entry><title type="html">协程的用法</title><link href="https://roshameow.github.io//personal_homepage/tool/asyncio/" rel="alternate" type="text/html" title="协程的用法" /><published>2025-01-16T00:00:00+00:00</published><updated>2025-01-18T20:58:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/tool/asyncio</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/tool/asyncio/"><![CDATA[<h2 id="python-协程的用法">python 协程的用法</h2>

<ul>
  <li>yield(生成器)</li>
  <li>future</li>
  <li>asyncio
    <ul>
      <li>async 函数不会马上执行其中代码, 而是返回coroutine function</li>
      <li>await 相当于yield from
        <ul>
          <li>后面可以是task/coroutine/future</li>
        </ul>
      </li>
      <li>task: 可以被执行的函数
        <ul>
          <li>create_task 可以生成task</li>
          <li>await 也会</li>
          <li>asyncio.run() 的时候会执行task</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>特点:
    <ul>
      <li>需要每个子任务结束主动告知(运行结束, return)</li>
    </ul>
  </li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="tool" /><category term="content" /><category term="python" /><summary type="html"><![CDATA[python 协程的用法]]></summary></entry><entry><title type="html">worldquant BRAIN 股票因子 (二) – 因子思路</title><link href="https://roshameow.github.io//personal_homepage/finance/alphas2/" rel="alternate" type="text/html" title="worldquant BRAIN 股票因子 (二) – 因子思路" /><published>2025-01-15T00:00:00+00:00</published><updated>2025-01-18T21:09:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/finance/alphas2</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/finance/alphas2/"><![CDATA[<p>一些因子的来源和原理</p>

<h2 id="对公司经营状况的预估基本数据">对公司经营状况的预估(基本数据)</h2>

<p>fundamental datasets</p>

<ul>
  <li>运营盈利: 只对大型公司有效
    <ul>
      <li>盈利/支出
        <ul>
          <li><code class="language-plaintext highlighter-rouge">-rank(ebit/capex)</code>
            <ul>
              <li>投入更多到运营盈利上的公司不怎么样</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>资产估值/盈利
        <ul>
          <li><code class="language-plaintext highlighter-rouge">alpha = -group_rank(fnd2_ebitdm, industry)-group_rank(fnd2_ebitfr, industry); group_rank(fn_assets_fair_val_a,industry)&gt;0.5?alpha*2 : alpha</code>
            <ul>
              <li><code class="language-plaintext highlighter-rouge">fnd2_ebitdm</code> domestic ebit, <code class="language-plaintext highlighter-rouge">fnd2_ebitfr</code> foreign ebit</li>
              <li><code class="language-plaintext highlighter-rouge">fn_assets_fair_val_a</code> 资产估值</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>留存收益: 未分配给股东的利润
    <ul>
      <li><code class="language-plaintext highlighter-rouge">rank(ts_delta(retained_earnings / sharesout, 90))</code>
        <ul>
          <li>留存收益/股本=每股留存收益: 不受公司规模影响</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">-ts_rank(retained_earnings,250)</code>
        <ul>
          <li>留存收益比历史减少, 可能是分红给股东了</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>营业收入:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ts_rank(operating_income,252)</code>
        <ul>
          <li>营业收入越高越好,</li>
          <li>结合相对股价看(operating_income/close), 如果营业收入增长而股价未能跟上，可能意味着市场尚未充分定价公司改善的前景</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>负债
    <ul>
      <li>短期债务: 限制同行业比较
        <ul>
          <li><code class="language-plaintext highlighter-rouge">zscore(cash_st/debt_st)</code>
            <ul>
              <li>现金流越高, 还债能力越强</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>负债公允价值（Fair Value of Liabilities）,公司负债在市场上的当前价值
        <ul>
          <li><code class="language-plaintext highlighter-rouge">-ts_rank(fn_liab_fair_val_l1_a,252)</code></li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">liabilities/assets</code>, <code class="language-plaintext highlighter-rouge">debt/assets</code>
        <ul>
          <li>高杠杆可能带来高回报</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>收入
    <ul>
      <li>税前收入, 销售数量(sales)
        <ul>
          <li><code class="language-plaintext highlighter-rouge">quantile(ts_rank(pretax_income,250))</code>
            <ul>
              <li>税前收入越靠前的公司越好</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>递延收入: 订阅型业务, 长期合约, 预付款业务
        <ul>
          <li><code class="language-plaintext highlighter-rouge">slope = ts_regression(fnd6_newqv1300_drcq,step(1),252,rettype=2); rank(slope)</code></li>
          <li>计算<code class="language-plaintext highlighter-rouge">dr</code>(deferred revenue)的斜率, 增长说明需求增加, 可能股票会涨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="对外部事件的响应">对外部事件的响应</h2>

<ul>
  <li>新闻影响
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ts_backfill(vec_avg(nws12_prez_4l),504)</code>
        <ul>
          <li>新闻发布后股价提升4%的时间</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">(ts_arg_max(ts_backfill(news_session_range, 20), 60))</code>
        <ul>
          <li>新闻后的波动范围(high-low)越大, 应该做多?? 一个季度内, 到达最大波动范围的最近时间. 越长说明波动衰减的正常. 不会极端的受到</li>
          <li>需要用随时间变化快的decay, 和trade_when控制换手率</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>社媒:  对volume做neuntralize
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-scl12_buzz</code>
        <ul>
          <li>讨论多的认为是负面情绪</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">ts_std_dev(ts_backfill(snt_social_value,60),60)</code>
        <ul>
          <li>在一段时间内有关注是好事, 注意区分不同类型的股票</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">-ts_mean(pv13_ustomergraphrank_hub_rank,504)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">hub</code> 公司在网络中的中心度, 越低说明对其他合作伙伴依赖越少, 更稳定, 注意区分不同类型的股票</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>volatility(波动率)
    <ul>
      <li><code class="language-plaintext highlighter-rouge">(implied_volatility_call_120/parkinson_volatility_120)^0.1</code>
        <ul>
          <li>历史波动率: daily return的标准差</li>
          <li>Implied Volatility(隐含波动率): 通过期权定价模型计算</li>
          <li>Parkinson波动率: 通过价格区间(high-low/close)计算</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">trade_when(pcr_oi_270 &lt; 1, (implied_volatility_call_270-implied_volatility_put_270), -1)</code>
        <ul>
          <li><code class="language-plaintext highlighter-rouge">pcr_oi_270</code> (put-call-ratio)未平仓合约数, 小于1 的话(call&gt;put)说明市场看涨</li>
          <li>可以根据历史波动率分组, 提升subuniverse-test, 很有效</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="对市场表现的预估量价数据">对市场表现的预估(量价数据)</h2>

<p>Price-volume datasets</p>

<ul>
  <li>成交量: 根据市值(cap)分组, 不同波动时期区别对待
    <ul>
      <li><code class="language-plaintext highlighter-rouge">alpha = (1/volume);group = bucket(rank(cap),range ='0.25,1,0.25');group_rank(alpha,group);</code>
        <ul>
          <li>成交量太活跃不是好事</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>相关性
    <ul>
      <li><code class="language-plaintext highlighter-rouge">-ts_corr(ts_backfill(fscore_momentum,66),ts_backfill(fscore_value,66),756)</code>
        <ul>
          <li>估值(市盈率（P/E）、市净率（P/B）等财务指标来估算)和动量(股票价格变化率计算)的相关性高, 说明股票价格和价值分离?</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>风险
    <ul>
      <li><code class="language-plaintext highlighter-rouge">SR = systematic_risk_last_60_days;USR = unsystematic_risk_last_60_days;zscore(USR + SR)</code>
        <ul>
          <li>总风险, 高风险是好的?</li>
          <li>去掉和指数相关性高的股票?</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">market_ret = ts_product(1+group_mean(returns,1,market),250)-1;rfr = vec_avg(fnd6_newqeventv110_optrfrq);expected_return = rfr+beta_last_360_days_spy*(market_ret-rfr);actual_return = ts_product(returns+1,250)-1;actual_return-expected_return</code>
        <ul>
          <li>CAPM(Capital Asset Pricing Model): <code class="language-plaintext highlighter-rouge">rfr</code> 是risk free rate + beta * (return - rfr)</li>
          <li>实际比CAPM计算的return高是好事</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="参考资料">参考资料</h2>

<p>[1]  https://platform.worldquantbrain.com/learn/documentation</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="finance" /><category term="content" /><category term="stock" /><category term="alpha" /><summary type="html"><![CDATA[一些因子的来源和原理]]></summary></entry><entry><title type="html">worldquant BRAIN 股票因子 (一) – 仿真测试</title><link href="https://roshameow.github.io//personal_homepage/finance/alphas/" rel="alternate" type="text/html" title="worldquant BRAIN 股票因子 (一) – 仿真测试" /><published>2025-01-07T00:00:00+00:00</published><updated>2025-01-18T21:07:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/finance/alphas</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/finance/alphas/"><![CDATA[<p>选择在模拟盘中表现好的因子投资</p>

<h2 id="仿真">仿真</h2>

<h3 id="仿真参数">仿真参数</h3>

<p>分为数据库选择, 和后处理两部分</p>

<ul>
  <li>Delay: 当天(在当天closed前根据当天数据交易), 或+1天</li>
  <li>Test Period: 把仿真的5年时间分出一部分作为test, PnL图上orange的部分</li>
  <li>
    <p>Universe(股票范围): Top3000指日平均 <code class="language-plaintext highlighter-rouge">volume</code> 最大的3000支</p>
  </li>
  <li>Decay: 自带的一个linear decay(前n天)</li>
  <li>pasteurized: ? 只考虑universe以内的alpha?</li>
  <li>Nan Handling: 操作不可控? OFF的话, 有Nan的值会被平仓(全部卖出)</li>
  <li>Unit Handling: 单位不匹配时报warning</li>
  <li>truncation: 设置maximum weight上限: 建议设置0.05~0.1 (entailing 5-10%)之间</li>
  <li>neutralize(标准化): 让mean(alpha)=0, 时间(<code class="language-plaintext highlighter-rouge">ts_neutralize</code>)上做neutralize避免长期趋势. 同期(<code class="language-plaintext highlighter-rouge">group_neutralize</code>)的做避免不同类型股票的不公平比较.</li>
</ul>

<h2 id="仿真交易流程">仿真交易流程</h2>

<ul>
  <li>输入为  <code class="language-plaintext highlighter-rouge">Matrix</code>, 按照时间顺序交易</li>
  <li><a href="https://platform.worldquantbrain.com/learn/documentation/create-alphas/how-brain-platform-works">仿真交易规则</a>:
    <ul>
      <li>每天用恒定的账面规模(<code class="language-plaintext highlighter-rouge">book size</code>)交易,
        <ul>
          <li>book size 为$20 million. 有$10 million现金, 投资上限为$20million.</li>
        </ul>
      </li>
      <li>alpha apply到每只股票上得到alpha value</li>
      <li>L1 归一化,  得到每只股票的<code class="language-plaintext highlighter-rouge">weight</code></li>
      <li>每天在每只股票上投资 <code class="language-plaintext highlighter-rouge">weight*booksize</code></li>
      <li>计算<code class="language-plaintext highlighter-rouge">PnL</code></li>
    </ul>
  </li>
</ul>

<h2 id="数据">数据</h2>

<p>有<code class="language-plaintext highlighter-rouge">Matrix</code>, <code class="language-plaintext highlighter-rouge">Vector</code>, <code class="language-plaintext highlighter-rouge">Group</code> 三种</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">Matrix</code> : 天数 x 股票的2d array. 普通的alpha可以用</li>
  <li><code class="language-plaintext highlighter-rouge">Vector</code>: 每天每只股票可能有0-n个数值, 比如新闻. 需要用vector_operator处理</li>
  <li><code class="language-plaintext highlighter-rouge">Group</code>: 每只股票一个group_id. 用于group_operator的group参数</li>
</ul>

<h2 id="测试结果">测试结果</h2>

<h3 id="术语">术语</h3>

<ul>
  <li>PnL(profit and loss): <code class="language-plaintext highlighter-rouge">daily_PnL = sum(size of position * daily_return)</code>
    <ul>
      <li>每个股票的 <code class="language-plaintext highlighter-rouge">daily_return= (today’s close / yesterday’s close) – 1.0 </code></li>
    </ul>
  </li>
  <li>Returns: <code class="language-plaintext highlighter-rouge">Return = annualized PnL / Half of Book Size</code></li>
  <li>Drowndown: PnL最大的一次下降, 用half of booksize归一化为百分比</li>
  <li>Long/Short(做多, 做空): 在这里就指买入/卖出
    <ul>
      <li>Long/short Count: 做多/做空 股票的数量</li>
    </ul>
  </li>
  <li><a href="https://www.investopedia.com/terms/v/volume.asp#:~:text=Volume%20is%20the%20amount%20of,its%20daily%20open%20and%20close">Volume(成交量)</a> : 一段时间的交易数量</li>
  <li>Margin(边缘收益): <code class="language-plaintext highlighter-rouge">Margin=PnL/TotalDollarsTraded</code>
    <ul>
      <li>一段时间内每个dollor的收益, 和可能会用到的手续费有关.</li>
    </ul>
  </li>
  <li>cap(市值)</li>
</ul>

<h3 id="通过指标">通过指标</h3>

<table>
  <thead>
    <tr>
      <th><a href="https://platform.worldquantbrain.com/learn/documentation/interpret-results/alpha-submission">指标</a></th>
      <th>要求</th>
      <th>公式</th>
      <th>优化方向</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Sharpe_ratio">Sharpe(夏普率, related metric, information ratio, IR)</a></td>
      <td>Delay-0: <code class="language-plaintext highlighter-rouge">Sharpe &gt; 2</code><br />Delay-1: <code class="language-plaintext highlighter-rouge">Sharpe &gt; 1.25</code></td>
      <td><code class="language-plaintext highlighter-rouge">Sharpe=mean(PnL)/stdev(PnL)*sqrt(252)</code><br /><br /><code class="language-plaintext highlighter-rouge">*sqrt(252)</code> 年化</td>
      <td> </td>
    </tr>
    <tr>
      <td>Sub-universe Sharpe</td>
      <td> </td>
      <td><code class="language-plaintext highlighter-rouge">subuniverse_sharpe &gt;= 0.75 * sqrt(subuniverse_size / alpha_universe_size) * alpha_sharpe</code><br /><br />不在sub-universe 的股票赋NaN, 自动加上market neutralization, 并乘上scale?<br /><br /></td>
      <td>让alpha少受公司规模, 流动性的影响<br />避免使用<code class="language-plaintext highlighter-rouge">1-rank(cap), rank(-assets)</code><br />对<code class="language-plaintext highlighter-rouge">volume*close</code> 不在一个水平的stock, 用不同的decay参数</td>
    </tr>
    <tr>
      <td><a href="https://support.worldquantbrain.com/hc/en-us/articles/20251419309719-How-to-improve-Turnover">Turnover(换手率)</a></td>
      <td><code class="language-plaintext highlighter-rouge">1% &lt; Turnover &lt; 70%</code><br />建议 <code class="language-plaintext highlighter-rouge">Turnover &lt; 40%</code></td>
      <td><code class="language-plaintext highlighter-rouge">avg(daily trading volume/Booksize)</code></td>
      <td>减少turnover: 增加滤波(decay, ts_mean)<br />用trade_when限制开仓条件</td>
    </tr>
    <tr>
      <td><strong><a href="https://support.worldquantbrain.com/hc/en-us/articles/20251386376471-How-to-increase-fitness-of-alphas?">Fitness(健康度)</a></strong><br />评价alpha优劣的指标</td>
      <td>Delay-0: <code class="language-plaintext highlighter-rouge">fitness &gt; 1.3</code><br />Delay-1: <code class="language-plaintext highlighter-rouge">fitness &gt; 1</code></td>
      <td><code class="language-plaintext highlighter-rouge">Fitness = Sharpe*sqrt(abs(Returns)/Max(Turnover,0.125))</code></td>
      <td> </td>
    </tr>
    <tr>
      <td>Weight test</td>
      <td>1. 在长时间内, non-zero weight的股票数不能太少<br />2. 某一个股票的weight不能占比太大<br /><code class="language-plaintext highlighter-rouge">max(weight) &lt; 10%</code> <br />随股票范围变动</td>
      <td> </td>
      <td>- truncation: 设置maximum weight上限: 建议设置0.05~0.1 (entailing 5-10%)之间<br />- 优化weight 分布: rank</td>
    </tr>
    <tr>
      <td>Self Correlation</td>
      <td>和现有alpha不相关:<br /><code class="language-plaintext highlighter-rouge">&lt; 0.7 PnL correlation</code><br />, 或优化现有alpha:<br /><code class="language-plaintext highlighter-rouge">Sharpe &gt; 110% * correlated Sharpe</code></td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td><a href="https://platform.worldquantbrain.com/learn/documentation/interpret-results/parameters-simulation-results#is-semi-os-os">Out-of-sample(OS)</a></td>
      <td>提交后在真实市场测试</td>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="操作">操作</h2>

<ul>
  <li>数据接口: https://platform.worldquantbrain.com/data</li>
  <li>支持运算: https://platform.worldquantbrain.com/learn/operators</li>
  <li><a href="https://platform.worldquantbrain.com/learn/documentation/discover-brain/introduction-brain-expression-language">代码语法</a>:
    <ul>
      <li>只用给出的运算符</li>
      <li>每行用 <code class="language-plaintext highlighter-rouge">;</code> 结尾
常用的operator</li>
    </ul>
  </li>
  <li>调整分布
    <ul>
      <li>zscore: 让数据的mean=0, var=1. 假设数据是高斯分布的情况下标准化.</li>
      <li>rank: 不改变单调性, 把数据调整成均匀分布</li>
      <li>quantile 把数据调整成某个分布</li>
    </ul>
  </li>
</ul>

<h2 id="参考资料">参考资料</h2>

<p>[1]   https://support.worldquantbrain.com/hc/en-us/community/posts/28643095649943–新人科普-一文助你成为BRAIN兼职研究顾问</p>

<p>[2]  https://support.worldquantbrain.com/hc/en-us/community/posts/19273239621399–Alpha灵感启示录-合集-持续更新收录中</p>

<p>[3]  https://support.worldquantbrain.com/hc/en-us/community/posts/22863075241623–学习资料-BRAIN平台自学路径图推荐</p>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="finance" /><category term="content" /><category term="stock" /><category term="alpha" /><category term="simulation" /><summary type="html"><![CDATA[选择在模拟盘中表现好的因子投资]]></summary></entry><entry><title type="html">blender学习: 用几何节点做程序化城市</title><link href="https://roshameow.github.io//personal_homepage/blender/blender-learning18/" rel="alternate" type="text/html" title="blender学习: 用几何节点做程序化城市" /><published>2025-01-04T00:00:00+00:00</published><updated>2025-01-07T17:14:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/blender/blender-learning18</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/blender/blender-learning18/"><![CDATA[<p>参考<a href="https://www.youtube.com/watch?v=LheRoTgym8g">这个教学</a></p>

<p>1:  <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250105115526.png" alt="Pasted image 20250105115526.png" width="150" />  -&gt; 2:  <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250105121905.png" alt="Pasted image 20250105121905.png" width="150" />  -&gt; 3: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106164220.png" alt="Pasted image 20250106164220.png" width="150" /> -&gt; 4: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106164521.png" alt="Pasted image 20250106164521.png" width="150" /> -&gt; 5: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106164825.png" alt="Pasted image 20250106164825.png" width="150" /></p>

<ul>
  <li>制作道路:
    <ol>
      <li>制作随机网格: 随机2, 3层细分
        <ul>
          <li>用二层 <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/subdivide_mesh.html">subdivide Mesh</a></li>
          <li>随机选一些内部网格 (<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/geometry/operations/separate_geometry.html">Separate Geometry Node -&gt; Face</a> ) 再进行一层subdivide
            <ul>
              <li>输入Boolean的随机值</li>
              <li>输出选中的和未选中的不同处理</li>
              <li>用<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/geometry/join_geometry.html">Join Gemetry Node</a>  融合在一起</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>制作随机扭曲: 把随机的mesh merge在一起
        <ul>
          <li>用<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/geometry/operations/merge_by_distance.html">Merge by Distance Node</a> 融合: 输入Boolean的随机值, distance选择0.26( 稍 &gt; 2级细分, 即1/4)</li>
          <li>再次用0.01的distance 融合: 去除重复的边</li>
        </ul>
      </li>
      <li>把网格转成道路
        <ul>
          <li>mesh转成折线curve: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/mesh_to_curve.html">Mesh to Curve</a></li>
          <li>折线curve转成圆角曲线: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/mesh_to_curve.html">Fillet Curve</a> (类似Bevel倒角的效果)
            <ul>
              <li>Count 控制中间点的个数, Radius控制圆角弧度大小, 选择Limit Radius 保证圆角起终点不会超出范围(什么情况是需要超出范围的吗? 这个选项总是要选)</li>
            </ul>
          </li>
          <li><strong>转成道路: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/curve/operations/curve_to_mesh.html">Curve to Mesh</a> (效果为Curve沿Profile Curve 挤出)</strong>
            <ul>
              <li>Curve 处输入我们的道路curve</li>
              <li>Profile Curve 处用<a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/curve/primitives/curve_line.html">Curve Line</a> 输入一个固定长度线段Curve</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>增加厚度: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/extrude_mesh.html">Extrude Mesh Node</a> 沿面的法相挤出</li>
      <li>关闭自动的Smooth Shading: <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/write/set_shade_smooth.html">Set Shade Smooth Node</a></li>
    </ol>
  </li>
</ul>

<p>1: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106204640.png" alt="Pasted image 20250106204640.png" width="150" />  -&gt; 2: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106205132.png" alt="Pasted image 20250106205132.png" width="150" />  -&gt; 3: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106214511.png" alt="Pasted image 20250106214511.png" width="150" /> -&gt; 4: <img src="/personal_homepage/docs/attachment/Pasted%20image%2020250106214738.png" alt="Pasted image 20250106214738.png" width="150" /></p>

<ul>
  <li>制作建筑物: 安插在道路网格的间隙
    <ol>
      <li>制作底座: 把折线道路(道路步骤2的结果)向内挤出
        <ul>
          <li><a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/extrude_mesh.html">Extrude Mesh Node</a> 沿面的法相挤出, 但是厚度为0</li>
          <li>选中输出<code class="language-plaintext highlighter-rouge">Top</code>(新生成的面)向内scale</li>
        </ul>
      </li>
      <li>制作楼体:
        <ul>
          <li>把底座内部向上拉伸</li>
          <li>去掉第一步制作底座时没用的mesh, 只保留底座拉伸部分</li>
        </ul>
      </li>
      <li>制作屋顶:
        <ul>
          <li>选中楼体顶部:
            <ul>
              <li><a href="https://docs.blender.org/manual/en/3.1/modeling/geometry_nodes/input/normal.html">Normal Node</a> + <a href="https://docs.blender.org/manual/en/latest/compositing/types/vector/separate_xyz.html">Spearate XYZ Node</a> 的<code class="language-plaintext highlighter-rouge">Z</code>输出, 连接到 <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/extrude_mesh.html">Extrude Mesh Node</a> 的<code class="language-plaintext highlighter-rouge">Selection</code> 上</li>
              <li>另一种方法是直接选中楼体时的<code class="language-plaintext highlighter-rouge">Top</code> 输出, 连接到 <a href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/mesh/operations/extrude_mesh.html">Extrude Mesh Node</a> 的<code class="language-plaintext highlighter-rouge">Selection</code> 上</li>
            </ul>
          </li>
          <li>把楼体顶部向下向内挤出(和上一步制作楼体的方法一样)</li>
        </ul>
      </li>
      <li>把街区内部进一步切分, 和道路放在一起</li>
    </ol>
  </li>
</ul>

<p><img src="/personal_homepage/docs/attachment/Pasted%20image%2020250107055846.png" alt="Pasted image 20250107055846.png" width="150" /></p>

<ul>
  <li>shading: 在cycles渲染模式下
    <ul>
      <li>world: 添加一个Sky Texture, 适当调整参数</li>
      <li>object:
        <ul>
          <li>楼体: 每幢楼随机两个贴图
            <ul>
              <li>用<a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/input/geometry.html">Geometry Node</a> 的random per Island(每个connected component随机) 的功能 + constant Color Ramp(把数值映射成 0 或 1 )</li>
              <li>mix shader混合</li>
            </ul>
          </li>
          <li>楼顶: 用<a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/input/geometry.html">Geometry Node</a> 的normal +  <a href="https://docs.blender.org/manual/en/latest/compositing/types/vector/separate_xyz.html">Spearate XYZ Node</a> 的<code class="language-plaintext highlighter-rouge">Z</code>输出, 选中楼顶</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="texture-coordinate-的设置"><a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/input/texture_coordinate.html">texture Coordinate</a> 的设置</h2>

<ul>
  <li>我们用<a href="https://docs.blender.org/manual/en/latest/render/shader_nodes/textures/image.html">Image Texture</a> 设置颜色的映射时, 把默认的 flat 改为 box
    <ul>
      <li>flat的映射: <img src="https://docs.blender.org/manual/en/latest/_images/render_shader-nodes_textures_image_projection-flat.png" alt="flat" />Sphere的映射方法: <img src="https://docs.blender.org/manual/en/latest/_images/render_shader-nodes_textures_image_projection-box.png" alt="box" /></li>
    </ul>
  </li>
</ul>

<h2 id="用到的blender的一些快捷键功能">用到的blender的一些快捷键功能</h2>

<ul>
  <li>打开关闭侧边 Transform栏: N</li>
  <li>Object Mode:
    <ul>
      <li><a href="https://docs.blender.org/manual/en/latest/scene_layout/object/editing/apply.html">Apply(应用变形)</a>: Command + A
        <ul>
          <li>比例尺(Apply Scale): 应用后, 物体上的变换, 由比例变成实际距离?
            <ul>
              <li>比如400scale的物体, 应用前 0.1 的变换, 和应用后40m的变换等价</li>
              <li>blender的滑块单位是0.1, 可能是有时候物体太大, 按比例调整不方便?</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Geometry Nodes合并成group
    <ul>
      <li>在原有Node输入的地方可以加input Node
        <ul>
          <li>input Node的参数不能改名字</li>
          <li>Node内部的参数不能改成输入😮‍💨</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="blender" /><category term="content" /><category term="geometry_node" /><summary type="html"><![CDATA[参考这个教学]]></summary></entry><entry><title type="html">雪花制作</title><link href="https://roshameow.github.io//personal_homepage/blender/snowflake/" rel="alternate" type="text/html" title="雪花制作" /><published>2025-01-02T00:00:00+00:00</published><updated>2025-01-03T10:10:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/blender/snowflake</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/blender/snowflake/"><![CDATA[<h2 id="六方晶系"><a href="https://en.wikipedia.org/wiki/Hexagonal_crystal_family">六方晶系</a></h2>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="blender" /><category term="content" /><summary type="html"><![CDATA[六方晶系]]></summary></entry><entry><title type="html">终端配置</title><link href="https://roshameow.github.io//personal_homepage/tool/setting-shortcut/" rel="alternate" type="text/html" title="终端配置" /><published>2025-01-01T00:00:00+00:00</published><updated>2025-01-03T21:58:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/tool/setting-shortcut</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/tool/setting-shortcut/"><![CDATA[<h2 id="zsh">zsh</h2>

<h2 id="powershell">powershell</h2>

<ul>
  <li>找到, 或创建<code class="language-plaintext highlighter-rouge">$PROFILE</code> 文件:
    <ul>
      <li>在powershell里直接输入<code class="language-plaintext highlighter-rouge">$PROFILE</code> 查看路径</li>
      <li>创建: <code class="language-plaintext highlighter-rouge">New-Item -Path C:\MyFolder -Name "Example.txt" -ItemType File</code></li>
      <li>查看: <code class="language-plaintext highlighter-rouge">cat</code></li>
      <li>写入: <code class="language-plaintext highlighter-rouge">Set-Content -Path "NewFile.txt" -Value "This is a test file."</code></li>
    </ul>
  </li>
  <li>打开文件</li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="tool" /><category term="content" /><summary type="html"><![CDATA[zsh]]></summary></entry><entry><title type="html">3d模型资源, 数据库</title><link href="https://roshameow.github.io//personal_homepage/data/blender-learning17/" rel="alternate" type="text/html" title="3d模型资源, 数据库" /><published>2024-12-22T00:00:00+00:00</published><updated>2025-01-06T06:50:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/data/blender-learning17</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/data/blender-learning17/"><![CDATA[<h2 id="3d模型文件格式">3d模型文件格式</h2>

<table>
  <thead>
    <tr>
      <th>格式</th>
      <th>格式</th>
      <th>特点</th>
      <th>常用用途</th>
      <th>开发商</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">.obj</a></td>
      <td>vertex(v): 由3d coordinate表示<br />texture(vt): 2d coordinate<br />normal(vn): 3d vector<br />face(f): vertex索引/texture索引/normal索引</td>
      <td> </td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>.stl</td>
      <td> </td>
      <td> </td>
      <td>3d打印</td>
      <td> </td>
    </tr>
    <tr>
      <td>Polygon File Format<br /><a href="https://en.wikipedia.org/wiki/PLY_(file_format)">.ply</a></td>
      <td>1. header 数据结构<br />element 对象(vertex) 数量(14)<br />property 类型(float) 名称(x/y/z…)<br />2. 具体数据<br />两部分构成</td>
      <td>支持颜色、法线和其他属性</td>
      <td>点云数据</td>
      <td> </td>
    </tr>
    <tr>
      <td>.fbx</td>
      <td> </td>
      <td> </td>
      <td> </td>
      <td>Autodesk</td>
    </tr>
    <tr>
      <td>Graphics Language Transmission Format<br /><a href="https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/figures/gltfOverview-2.0.0b.png">.gltf</a>, .glb<br /></td>
      <td> </td>
      <td>现代, 省空间</td>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>.3ds</td>
      <td> </td>
      <td>过时</td>
      <td>模型存储</td>
      <td>Autodesk</td>
    </tr>
    <tr>
      <td>.las</td>
      <td> </td>
      <td> </td>
      <td>地理信息(GIS)</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h2 id="模型">模型</h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="https://sketchfab.com/feed">sketchfab</a></td>
      <td> </td>
    </tr>
    <tr>
      <td><a href="https://www.cgmodel.com">cg模型网</a></td>
      <td>国风模型</td>
    </tr>
    <tr>
      <td><a href="https://cubebrush.co">cubebrush</a></td>
      <td> </td>
    </tr>
    <tr>
      <td><a href="https://free3d.com">free3d</a></td>
      <td> </td>
    </tr>
    <tr>
      <td><a href="https://www.blender.org/download/demo-files/">blender官网demo</a></td>
      <td> </td>
    </tr>
    <tr>
      <td><a href="https://blendermarket.com">blendermarket</a></td>
      <td>.blend格式, 免费比较少</td>
    </tr>
    <tr>
      <td><a href="https://www.daz3d.com">Daz</a></td>
      <td>写实风格, 素体<br /><a href="https://render-state.to">Render-State</a> : daz链接</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
  </tbody>
</table>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="data" /><category term="content" /><summary type="html"><![CDATA[3d模型文件格式]]></summary></entry><entry><title type="html">Serverless服务</title><link href="https://roshameow.github.io//personal_homepage/webpage/serverless/" rel="alternate" type="text/html" title="Serverless服务" /><published>2024-12-19T00:00:00+00:00</published><updated>2025-01-01T04:48:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/webpage/serverless</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/webpage/serverless/"><![CDATA[<p>租虚拟服务器代替真实服务器</p>

<ul>
  <li>优点:
    <ul>
      <li>减少运维麻烦: 比如操作系统的安装和管理, 硬件的配置, 网络的配置(防火墙, 隔离, 权限等), 运行环境和依赖的配置, 容灾备份等</li>
      <li>自动扩展: 不用手动配置负载均衡器, 调整服务器数量</li>
      <li>自动优化: 跟据函数的内存大小, 自动优化代码的执行时间和性能</li>
      <li>可能更省钱: 用运行资源(程序执行时间, cpu, 内存, 公网流量等) 计费, 而不是服务器数量计费</li>
    </ul>
  </li>
</ul>

<p>AWS Lambda</p>

<ul>
  <li>每个lambda function 单独配置权限, 类似github action
    <h2 id="阿里云">阿里云</h2>
  </li>
  <li>负载均衡方案:
    <ul>
      <li>clb</li>
      <li>nlb</li>
      <li>alb</li>
    </ul>
  </li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="WebPage" /><category term="content" /><summary type="html"><![CDATA[租虚拟服务器代替真实服务器]]></summary></entry><entry><title type="html">blender学习: 五角星 ⭐️</title><link href="https://roshameow.github.io//personal_homepage/blender/blender-learning16/" rel="alternate" type="text/html" title="blender学习: 五角星 ⭐️" /><published>2024-12-18T00:00:00+00:00</published><updated>2024-12-25T17:07:00+00:00</updated><id>https://roshameow.github.io//personal_homepage/blender/blender-learning16</id><content type="html" xml:base="https://roshameow.github.io//personal_homepage/blender/blender-learning16/"><![CDATA[<p>参考<a href="https://www.bilibili.com/video/BV1v5kGYgEg9/">这个教学</a></p>

<ul>
  <li>添加circle mesh , 设置顶点 = 10 (刚添加时可以设置)</li>
  <li>选择5个顶点: Edit Mode下, Select -&gt; Checker Deselect(间隔式弃选)</li>
  <li>向内收缩形成五角星状轮廓</li>
  <li>Extrude(挤出) 变成五角星状围栏</li>
  <li>Loop cut(卡线) 分成三段</li>
  <li>上下层merge变为一点</li>
  <li>倒角(bevel), 细分(subdivide)</li>
</ul>

<p><img src="/personal_homepage/docs/attachment/Pasted%20image%2020241218224819.png" alt="Pasted image 20241218224819.png" width="150" /></p>

<h2 id="用到的blender的一些快捷键功能">用到的blender的一些快捷键功能</h2>

<ul>
  <li><a href="https://docs.blender.org/manual/en/latest/modeling/meshes/tools/loop.html">Loop Cut</a>(卡线): 在edge中间添新的顶点
    <ul>
      <li>添加loop cut: Ctrl+R</li>
      <li>选中已有的loop cut: Shift+Option+长按</li>
    </ul>
  </li>
  <li>E (<a href="https://docs.blender.org/manual/en/2.80/modeling/meshes/editing/duplicating/extrude.html">Extrude</a>, 挤出): 保持原顶点不变, 复制一份, 复制的和原来的用edge连接
    <ul>
      <li>selected face: <img src="https://docs.blender.org/manual/en/2.80/_images/modeling_meshes_editing_duplicating_extrude_face-before.png" alt="drawing" width="150" />  During extrude:  <img src="https://docs.blender.org/manual/en/2.80/_images/modeling_meshes_editing_duplicating_extrude_face-after.png" alt="drawing" width="150" />  </li>
    </ul>
  </li>
  <li>Edit Mode:
    <ul>
      <li>融合(merge): <a href="https://docs.blender.org/manual/en/latest/modeling/meshes/editing/mesh/merge.html">M</a>
        <ul>
          <li>merge to point和 向内收缩到头( S + 0 ) 效果一样的</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="用blender-script的情况">用blender script的情况</h2>

<ul>
  <li>流程特别固化, 用script比交互式操作容易的多</li>
  <li>开始我以为需要3d操作的loop cut会更麻烦, 顶点多了以后用代码就不方便描述了. 不过这个是我思维限制了, 用代码根本没必要loop cut, 直接把extrude重复多次就完了</li>
</ul>

<h3 id="把python-script-载入blender插件">把python script 载入blender插件</h3>

<p><strong>安装插件</strong></p>

<ol>
  <li>进入 <strong>Edit &gt; Preferences &gt; Add-ons</strong>。</li>
  <li>点击 <strong>Install</strong>，选择保存的 <code class="language-plaintext highlighter-rouge">.py</code> 文件。</li>
  <li>勾选插件以启用。</li>
</ol>

<p><strong>使用插件</strong></p>

<ol>
  <li>在Object Mode下，点击 <strong>Add &gt; Mesh &gt; Create Star</strong>。</li>
  <li>在左下角调整 <strong>Number of Points</strong>、<strong>Radius</strong> 和 <strong>Height</strong> 参数。</li>
</ol>

<h3 id="代码">代码</h3>

<ul>
  <li>script: <a href="https://gist.github.com/roshameow/2b5be662744414007ac39a4d10f530d9#file-create_star-py"><strong>create_star.py</strong></a></li>
  <li>add-on: <a href="https://gist.github.com/roshameow/2b5be662744414007ac39a4d10f530d9#file-star_addon-py"><strong>star_addon.py</strong></a></li>
</ul>]]></content><author><name>{&quot;name&quot;=&gt;nil, &quot;picture&quot;=&gt;&quot;/docs/images/logo.svg&quot;, &quot;email&quot;=&gt;&quot;w.liuatnk@gmail.com&quot;, &quot;twitter&quot;=&gt;nil}</name><email>w.liuatnk@gmail.com</email></author><category term="blender" /><category term="content" /><summary type="html"><![CDATA[参考这个教学]]></summary></entry></feed>